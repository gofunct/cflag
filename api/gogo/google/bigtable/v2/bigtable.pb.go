// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/bigtable/v2/bigtable.proto

package google_bigtable_v2

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "go.pedge.io/pb/gogo/google/api"
import google_protobuf1 "github.com/gogo/protobuf/types"
import google_rpc "go.pedge.io/pb/gogo/google/rpc"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Request message for Bigtable.ReadRows.
type ReadRowsRequest struct {
	// The unique name of the table from which to read.
	// Values are of the form
	// `projects/<project>/instances/<instance>/tables/<table>`.
	TableName string `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	// The row keys and/or ranges to read. If not specified, reads from all rows.
	Rows *RowSet `protobuf:"bytes,2,opt,name=rows" json:"rows,omitempty"`
	// The filter to apply to the contents of the specified row(s). If unset,
	// reads the entirety of each row.
	Filter *RowFilter `protobuf:"bytes,3,opt,name=filter" json:"filter,omitempty"`
	// The read will terminate after committing to N rows' worth of results. The
	// default (zero) is to return all results.
	RowsLimit int64 `protobuf:"varint,4,opt,name=rows_limit,json=rowsLimit,proto3" json:"rows_limit,omitempty"`
}

func (m *ReadRowsRequest) Reset()                    { *m = ReadRowsRequest{} }
func (m *ReadRowsRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadRowsRequest) ProtoMessage()               {}
func (*ReadRowsRequest) Descriptor() ([]byte, []int) { return fileDescriptorBigtable, []int{0} }

func (m *ReadRowsRequest) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *ReadRowsRequest) GetRows() *RowSet {
	if m != nil {
		return m.Rows
	}
	return nil
}

func (m *ReadRowsRequest) GetFilter() *RowFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *ReadRowsRequest) GetRowsLimit() int64 {
	if m != nil {
		return m.RowsLimit
	}
	return 0
}

// Response message for Bigtable.ReadRows.
type ReadRowsResponse struct {
	Chunks []*ReadRowsResponse_CellChunk `protobuf:"bytes,1,rep,name=chunks" json:"chunks,omitempty"`
	// Optionally the server might return the row key of the last row it
	// has scanned.  The client can use this to construct a more
	// efficient retry request if needed: any row keys or portions of
	// ranges less than this row key can be dropped from the request.
	// This is primarily useful for cases where the server has read a
	// lot of data that was filtered out since the last committed row
	// key, allowing the client to skip that work on a retry.
	LastScannedRowKey []byte `protobuf:"bytes,2,opt,name=last_scanned_row_key,json=lastScannedRowKey,proto3" json:"last_scanned_row_key,omitempty"`
}

func (m *ReadRowsResponse) Reset()                    { *m = ReadRowsResponse{} }
func (m *ReadRowsResponse) String() string            { return proto.CompactTextString(m) }
func (*ReadRowsResponse) ProtoMessage()               {}
func (*ReadRowsResponse) Descriptor() ([]byte, []int) { return fileDescriptorBigtable, []int{1} }

func (m *ReadRowsResponse) GetChunks() []*ReadRowsResponse_CellChunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

func (m *ReadRowsResponse) GetLastScannedRowKey() []byte {
	if m != nil {
		return m.LastScannedRowKey
	}
	return nil
}

// Specifies a piece of a row's contents returned as part of the read
// response stream.
type ReadRowsResponse_CellChunk struct {
	// The row key for this chunk of data.  If the row key is empty,
	// this CellChunk is a continuation of the same row as the previous
	// CellChunk in the response stream, even if that CellChunk was in a
	// previous ReadRowsResponse message.
	RowKey []byte `protobuf:"bytes,1,opt,name=row_key,json=rowKey,proto3" json:"row_key,omitempty"`
	// The column family name for this chunk of data.  If this message
	// is not present this CellChunk is a continuation of the same column
	// family as the previous CellChunk.  The empty string can occur as a
	// column family name in a response so clients must check
	// explicitly for the presence of this message, not just for
	// `family_name.value` being non-empty.
	FamilyName *google_protobuf1.StringValue `protobuf:"bytes,2,opt,name=family_name,json=familyName" json:"family_name,omitempty"`
	// The column qualifier for this chunk of data.  If this message
	// is not present, this CellChunk is a continuation of the same column
	// as the previous CellChunk.  Column qualifiers may be empty so
	// clients must check for the presence of this message, not just
	// for `qualifier.value` being non-empty.
	Qualifier *google_protobuf1.BytesValue `protobuf:"bytes,3,opt,name=qualifier" json:"qualifier,omitempty"`
	// The cell's stored timestamp, which also uniquely identifies it
	// within its column.  Values are always expressed in
	// microseconds, but individual tables may set a coarser
	// granularity to further restrict the allowed values. For
	// example, a table which specifies millisecond granularity will
	// only allow values of `timestamp_micros` which are multiples of
	// 1000.  Timestamps are only set in the first CellChunk per cell
	// (for cells split into multiple chunks).
	TimestampMicros int64 `protobuf:"varint,4,opt,name=timestamp_micros,json=timestampMicros,proto3" json:"timestamp_micros,omitempty"`
	// Labels applied to the cell by a
	// [RowFilter][google.bigtable.v2.RowFilter].  Labels are only set
	// on the first CellChunk per cell.
	Labels []string `protobuf:"bytes,5,rep,name=labels" json:"labels,omitempty"`
	// The value stored in the cell.  Cell values can be split across
	// multiple CellChunks.  In that case only the value field will be
	// set in CellChunks after the first: the timestamp and labels
	// will only be present in the first CellChunk, even if the first
	// CellChunk came in a previous ReadRowsResponse.
	Value []byte `protobuf:"bytes,6,opt,name=value,proto3" json:"value,omitempty"`
	// If this CellChunk is part of a chunked cell value and this is
	// not the final chunk of that cell, value_size will be set to the
	// total length of the cell value.  The client can use this size
	// to pre-allocate memory to hold the full cell value.
	ValueSize int32 `protobuf:"varint,7,opt,name=value_size,json=valueSize,proto3" json:"value_size,omitempty"`
	// Types that are valid to be assigned to RowStatus:
	//	*ReadRowsResponse_CellChunk_ResetRow
	//	*ReadRowsResponse_CellChunk_CommitRow
	RowStatus isReadRowsResponse_CellChunk_RowStatus `protobuf_oneof:"row_status"`
}

func (m *ReadRowsResponse_CellChunk) Reset()         { *m = ReadRowsResponse_CellChunk{} }
func (m *ReadRowsResponse_CellChunk) String() string { return proto.CompactTextString(m) }
func (*ReadRowsResponse_CellChunk) ProtoMessage()    {}
func (*ReadRowsResponse_CellChunk) Descriptor() ([]byte, []int) {
	return fileDescriptorBigtable, []int{1, 0}
}

type isReadRowsResponse_CellChunk_RowStatus interface {
	isReadRowsResponse_CellChunk_RowStatus()
}

type ReadRowsResponse_CellChunk_ResetRow struct {
	ResetRow bool `protobuf:"varint,8,opt,name=reset_row,json=resetRow,proto3,oneof"`
}
type ReadRowsResponse_CellChunk_CommitRow struct {
	CommitRow bool `protobuf:"varint,9,opt,name=commit_row,json=commitRow,proto3,oneof"`
}

func (*ReadRowsResponse_CellChunk_ResetRow) isReadRowsResponse_CellChunk_RowStatus()  {}
func (*ReadRowsResponse_CellChunk_CommitRow) isReadRowsResponse_CellChunk_RowStatus() {}

func (m *ReadRowsResponse_CellChunk) GetRowStatus() isReadRowsResponse_CellChunk_RowStatus {
	if m != nil {
		return m.RowStatus
	}
	return nil
}

func (m *ReadRowsResponse_CellChunk) GetRowKey() []byte {
	if m != nil {
		return m.RowKey
	}
	return nil
}

func (m *ReadRowsResponse_CellChunk) GetFamilyName() *google_protobuf1.StringValue {
	if m != nil {
		return m.FamilyName
	}
	return nil
}

func (m *ReadRowsResponse_CellChunk) GetQualifier() *google_protobuf1.BytesValue {
	if m != nil {
		return m.Qualifier
	}
	return nil
}

func (m *ReadRowsResponse_CellChunk) GetTimestampMicros() int64 {
	if m != nil {
		return m.TimestampMicros
	}
	return 0
}

func (m *ReadRowsResponse_CellChunk) GetLabels() []string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ReadRowsResponse_CellChunk) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *ReadRowsResponse_CellChunk) GetValueSize() int32 {
	if m != nil {
		return m.ValueSize
	}
	return 0
}

func (m *ReadRowsResponse_CellChunk) GetResetRow() bool {
	if x, ok := m.GetRowStatus().(*ReadRowsResponse_CellChunk_ResetRow); ok {
		return x.ResetRow
	}
	return false
}

func (m *ReadRowsResponse_CellChunk) GetCommitRow() bool {
	if x, ok := m.GetRowStatus().(*ReadRowsResponse_CellChunk_CommitRow); ok {
		return x.CommitRow
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReadRowsResponse_CellChunk) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReadRowsResponse_CellChunk_OneofMarshaler, _ReadRowsResponse_CellChunk_OneofUnmarshaler, _ReadRowsResponse_CellChunk_OneofSizer, []interface{}{
		(*ReadRowsResponse_CellChunk_ResetRow)(nil),
		(*ReadRowsResponse_CellChunk_CommitRow)(nil),
	}
}

func _ReadRowsResponse_CellChunk_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReadRowsResponse_CellChunk)
	// row_status
	switch x := m.RowStatus.(type) {
	case *ReadRowsResponse_CellChunk_ResetRow:
		t := uint64(0)
		if x.ResetRow {
			t = 1
		}
		_ = b.EncodeVarint(8<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *ReadRowsResponse_CellChunk_CommitRow:
		t := uint64(0)
		if x.CommitRow {
			t = 1
		}
		_ = b.EncodeVarint(9<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("ReadRowsResponse_CellChunk.RowStatus has unexpected type %T", x)
	}
	return nil
}

func _ReadRowsResponse_CellChunk_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReadRowsResponse_CellChunk)
	switch tag {
	case 8: // row_status.reset_row
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.RowStatus = &ReadRowsResponse_CellChunk_ResetRow{x != 0}
		return true, err
	case 9: // row_status.commit_row
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.RowStatus = &ReadRowsResponse_CellChunk_CommitRow{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _ReadRowsResponse_CellChunk_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReadRowsResponse_CellChunk)
	// row_status
	switch x := m.RowStatus.(type) {
	case *ReadRowsResponse_CellChunk_ResetRow:
		n += proto.SizeVarint(8<<3 | proto.WireVarint)
		n += 1
	case *ReadRowsResponse_CellChunk_CommitRow:
		n += proto.SizeVarint(9<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Request message for Bigtable.SampleRowKeys.
type SampleRowKeysRequest struct {
	// The unique name of the table from which to sample row keys.
	// Values are of the form
	// `projects/<project>/instances/<instance>/tables/<table>`.
	TableName string `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
}

func (m *SampleRowKeysRequest) Reset()                    { *m = SampleRowKeysRequest{} }
func (m *SampleRowKeysRequest) String() string            { return proto.CompactTextString(m) }
func (*SampleRowKeysRequest) ProtoMessage()               {}
func (*SampleRowKeysRequest) Descriptor() ([]byte, []int) { return fileDescriptorBigtable, []int{2} }

func (m *SampleRowKeysRequest) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

// Response message for Bigtable.SampleRowKeys.
type SampleRowKeysResponse struct {
	// Sorted streamed sequence of sample row keys in the table. The table might
	// have contents before the first row key in the list and after the last one,
	// but a key containing the empty string indicates "end of table" and will be
	// the last response given, if present.
	// Note that row keys in this list may not have ever been written to or read
	// from, and users should therefore not make any assumptions about the row key
	// structure that are specific to their use case.
	RowKey []byte `protobuf:"bytes,1,opt,name=row_key,json=rowKey,proto3" json:"row_key,omitempty"`
	// Approximate total storage space used by all rows in the table which precede
	// `row_key`. Buffering the contents of all rows between two subsequent
	// samples would require space roughly equal to the difference in their
	// `offset_bytes` fields.
	OffsetBytes int64 `protobuf:"varint,2,opt,name=offset_bytes,json=offsetBytes,proto3" json:"offset_bytes,omitempty"`
}

func (m *SampleRowKeysResponse) Reset()                    { *m = SampleRowKeysResponse{} }
func (m *SampleRowKeysResponse) String() string            { return proto.CompactTextString(m) }
func (*SampleRowKeysResponse) ProtoMessage()               {}
func (*SampleRowKeysResponse) Descriptor() ([]byte, []int) { return fileDescriptorBigtable, []int{3} }

func (m *SampleRowKeysResponse) GetRowKey() []byte {
	if m != nil {
		return m.RowKey
	}
	return nil
}

func (m *SampleRowKeysResponse) GetOffsetBytes() int64 {
	if m != nil {
		return m.OffsetBytes
	}
	return 0
}

// Request message for Bigtable.MutateRow.
type MutateRowRequest struct {
	// The unique name of the table to which the mutation should be applied.
	// Values are of the form
	// `projects/<project>/instances/<instance>/tables/<table>`.
	TableName string `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	// The key of the row to which the mutation should be applied.
	RowKey []byte `protobuf:"bytes,2,opt,name=row_key,json=rowKey,proto3" json:"row_key,omitempty"`
	// Changes to be atomically applied to the specified row. Entries are applied
	// in order, meaning that earlier mutations can be masked by later ones.
	// Must contain at least one entry and at most 100000.
	Mutations []*Mutation `protobuf:"bytes,3,rep,name=mutations" json:"mutations,omitempty"`
}

func (m *MutateRowRequest) Reset()                    { *m = MutateRowRequest{} }
func (m *MutateRowRequest) String() string            { return proto.CompactTextString(m) }
func (*MutateRowRequest) ProtoMessage()               {}
func (*MutateRowRequest) Descriptor() ([]byte, []int) { return fileDescriptorBigtable, []int{4} }

func (m *MutateRowRequest) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *MutateRowRequest) GetRowKey() []byte {
	if m != nil {
		return m.RowKey
	}
	return nil
}

func (m *MutateRowRequest) GetMutations() []*Mutation {
	if m != nil {
		return m.Mutations
	}
	return nil
}

// Response message for Bigtable.MutateRow.
type MutateRowResponse struct {
}

func (m *MutateRowResponse) Reset()                    { *m = MutateRowResponse{} }
func (m *MutateRowResponse) String() string            { return proto.CompactTextString(m) }
func (*MutateRowResponse) ProtoMessage()               {}
func (*MutateRowResponse) Descriptor() ([]byte, []int) { return fileDescriptorBigtable, []int{5} }

// Request message for BigtableService.MutateRows.
type MutateRowsRequest struct {
	// The unique name of the table to which the mutations should be applied.
	TableName string `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	// The row keys and corresponding mutations to be applied in bulk.
	// Each entry is applied as an atomic mutation, but the entries may be
	// applied in arbitrary order (even between entries for the same row).
	// At least one entry must be specified, and in total the entries can
	// contain at most 100000 mutations.
	Entries []*MutateRowsRequest_Entry `protobuf:"bytes,2,rep,name=entries" json:"entries,omitempty"`
}

func (m *MutateRowsRequest) Reset()                    { *m = MutateRowsRequest{} }
func (m *MutateRowsRequest) String() string            { return proto.CompactTextString(m) }
func (*MutateRowsRequest) ProtoMessage()               {}
func (*MutateRowsRequest) Descriptor() ([]byte, []int) { return fileDescriptorBigtable, []int{6} }

func (m *MutateRowsRequest) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *MutateRowsRequest) GetEntries() []*MutateRowsRequest_Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type MutateRowsRequest_Entry struct {
	// The key of the row to which the `mutations` should be applied.
	RowKey []byte `protobuf:"bytes,1,opt,name=row_key,json=rowKey,proto3" json:"row_key,omitempty"`
	// Changes to be atomically applied to the specified row. Mutations are
	// applied in order, meaning that earlier mutations can be masked by
	// later ones.
	// You must specify at least one mutation.
	Mutations []*Mutation `protobuf:"bytes,2,rep,name=mutations" json:"mutations,omitempty"`
}

func (m *MutateRowsRequest_Entry) Reset()         { *m = MutateRowsRequest_Entry{} }
func (m *MutateRowsRequest_Entry) String() string { return proto.CompactTextString(m) }
func (*MutateRowsRequest_Entry) ProtoMessage()    {}
func (*MutateRowsRequest_Entry) Descriptor() ([]byte, []int) {
	return fileDescriptorBigtable, []int{6, 0}
}

func (m *MutateRowsRequest_Entry) GetRowKey() []byte {
	if m != nil {
		return m.RowKey
	}
	return nil
}

func (m *MutateRowsRequest_Entry) GetMutations() []*Mutation {
	if m != nil {
		return m.Mutations
	}
	return nil
}

// Response message for BigtableService.MutateRows.
type MutateRowsResponse struct {
	// One or more results for Entries from the batch request.
	Entries []*MutateRowsResponse_Entry `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
}

func (m *MutateRowsResponse) Reset()                    { *m = MutateRowsResponse{} }
func (m *MutateRowsResponse) String() string            { return proto.CompactTextString(m) }
func (*MutateRowsResponse) ProtoMessage()               {}
func (*MutateRowsResponse) Descriptor() ([]byte, []int) { return fileDescriptorBigtable, []int{7} }

func (m *MutateRowsResponse) GetEntries() []*MutateRowsResponse_Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type MutateRowsResponse_Entry struct {
	// The index into the original request's `entries` list of the Entry
	// for which a result is being reported.
	Index int64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// The result of the request Entry identified by `index`.
	// Depending on how requests are batched during execution, it is possible
	// for one Entry to fail due to an error with another Entry. In the event
	// that this occurs, the same error will be reported for both entries.
	Status *google_rpc.Status `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *MutateRowsResponse_Entry) Reset()         { *m = MutateRowsResponse_Entry{} }
func (m *MutateRowsResponse_Entry) String() string { return proto.CompactTextString(m) }
func (*MutateRowsResponse_Entry) ProtoMessage()    {}
func (*MutateRowsResponse_Entry) Descriptor() ([]byte, []int) {
	return fileDescriptorBigtable, []int{7, 0}
}

func (m *MutateRowsResponse_Entry) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *MutateRowsResponse_Entry) GetStatus() *google_rpc.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// Request message for Bigtable.CheckAndMutateRow.
type CheckAndMutateRowRequest struct {
	// The unique name of the table to which the conditional mutation should be
	// applied.
	// Values are of the form
	// `projects/<project>/instances/<instance>/tables/<table>`.
	TableName string `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	// The key of the row to which the conditional mutation should be applied.
	RowKey []byte `protobuf:"bytes,2,opt,name=row_key,json=rowKey,proto3" json:"row_key,omitempty"`
	// The filter to be applied to the contents of the specified row. Depending
	// on whether or not any results are yielded, either `true_mutations` or
	// `false_mutations` will be executed. If unset, checks that the row contains
	// any values at all.
	PredicateFilter *RowFilter `protobuf:"bytes,6,opt,name=predicate_filter,json=predicateFilter" json:"predicate_filter,omitempty"`
	// Changes to be atomically applied to the specified row if `predicate_filter`
	// yields at least one cell when applied to `row_key`. Entries are applied in
	// order, meaning that earlier mutations can be masked by later ones.
	// Must contain at least one entry if `false_mutations` is empty, and at most
	// 100000.
	TrueMutations []*Mutation `protobuf:"bytes,4,rep,name=true_mutations,json=trueMutations" json:"true_mutations,omitempty"`
	// Changes to be atomically applied to the specified row if `predicate_filter`
	// does not yield any cells when applied to `row_key`. Entries are applied in
	// order, meaning that earlier mutations can be masked by later ones.
	// Must contain at least one entry if `true_mutations` is empty, and at most
	// 100000.
	FalseMutations []*Mutation `protobuf:"bytes,5,rep,name=false_mutations,json=falseMutations" json:"false_mutations,omitempty"`
}

func (m *CheckAndMutateRowRequest) Reset()                    { *m = CheckAndMutateRowRequest{} }
func (m *CheckAndMutateRowRequest) String() string            { return proto.CompactTextString(m) }
func (*CheckAndMutateRowRequest) ProtoMessage()               {}
func (*CheckAndMutateRowRequest) Descriptor() ([]byte, []int) { return fileDescriptorBigtable, []int{8} }

func (m *CheckAndMutateRowRequest) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *CheckAndMutateRowRequest) GetRowKey() []byte {
	if m != nil {
		return m.RowKey
	}
	return nil
}

func (m *CheckAndMutateRowRequest) GetPredicateFilter() *RowFilter {
	if m != nil {
		return m.PredicateFilter
	}
	return nil
}

func (m *CheckAndMutateRowRequest) GetTrueMutations() []*Mutation {
	if m != nil {
		return m.TrueMutations
	}
	return nil
}

func (m *CheckAndMutateRowRequest) GetFalseMutations() []*Mutation {
	if m != nil {
		return m.FalseMutations
	}
	return nil
}

// Response message for Bigtable.CheckAndMutateRow.
type CheckAndMutateRowResponse struct {
	// Whether or not the request's `predicate_filter` yielded any results for
	// the specified row.
	PredicateMatched bool `protobuf:"varint,1,opt,name=predicate_matched,json=predicateMatched,proto3" json:"predicate_matched,omitempty"`
}

func (m *CheckAndMutateRowResponse) Reset()         { *m = CheckAndMutateRowResponse{} }
func (m *CheckAndMutateRowResponse) String() string { return proto.CompactTextString(m) }
func (*CheckAndMutateRowResponse) ProtoMessage()    {}
func (*CheckAndMutateRowResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorBigtable, []int{9}
}

func (m *CheckAndMutateRowResponse) GetPredicateMatched() bool {
	if m != nil {
		return m.PredicateMatched
	}
	return false
}

// Request message for Bigtable.ReadModifyWriteRow.
type ReadModifyWriteRowRequest struct {
	// The unique name of the table to which the read/modify/write rules should be
	// applied.
	// Values are of the form
	// `projects/<project>/instances/<instance>/tables/<table>`.
	TableName string `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	// The key of the row to which the read/modify/write rules should be applied.
	RowKey []byte `protobuf:"bytes,2,opt,name=row_key,json=rowKey,proto3" json:"row_key,omitempty"`
	// Rules specifying how the specified row's contents are to be transformed
	// into writes. Entries are applied in order, meaning that earlier rules will
	// affect the results of later ones.
	Rules []*ReadModifyWriteRule `protobuf:"bytes,3,rep,name=rules" json:"rules,omitempty"`
}

func (m *ReadModifyWriteRowRequest) Reset()         { *m = ReadModifyWriteRowRequest{} }
func (m *ReadModifyWriteRowRequest) String() string { return proto.CompactTextString(m) }
func (*ReadModifyWriteRowRequest) ProtoMessage()    {}
func (*ReadModifyWriteRowRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorBigtable, []int{10}
}

func (m *ReadModifyWriteRowRequest) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *ReadModifyWriteRowRequest) GetRowKey() []byte {
	if m != nil {
		return m.RowKey
	}
	return nil
}

func (m *ReadModifyWriteRowRequest) GetRules() []*ReadModifyWriteRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// Response message for Bigtable.ReadModifyWriteRow.
type ReadModifyWriteRowResponse struct {
	// A Row containing the new contents of all cells modified by the request.
	Row *Row `protobuf:"bytes,1,opt,name=row" json:"row,omitempty"`
}

func (m *ReadModifyWriteRowResponse) Reset()         { *m = ReadModifyWriteRowResponse{} }
func (m *ReadModifyWriteRowResponse) String() string { return proto.CompactTextString(m) }
func (*ReadModifyWriteRowResponse) ProtoMessage()    {}
func (*ReadModifyWriteRowResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorBigtable, []int{11}
}

func (m *ReadModifyWriteRowResponse) GetRow() *Row {
	if m != nil {
		return m.Row
	}
	return nil
}

func init() {
	proto.RegisterType((*ReadRowsRequest)(nil), "google.bigtable.v2.ReadRowsRequest")
	proto.RegisterType((*ReadRowsResponse)(nil), "google.bigtable.v2.ReadRowsResponse")
	proto.RegisterType((*ReadRowsResponse_CellChunk)(nil), "google.bigtable.v2.ReadRowsResponse.CellChunk")
	proto.RegisterType((*SampleRowKeysRequest)(nil), "google.bigtable.v2.SampleRowKeysRequest")
	proto.RegisterType((*SampleRowKeysResponse)(nil), "google.bigtable.v2.SampleRowKeysResponse")
	proto.RegisterType((*MutateRowRequest)(nil), "google.bigtable.v2.MutateRowRequest")
	proto.RegisterType((*MutateRowResponse)(nil), "google.bigtable.v2.MutateRowResponse")
	proto.RegisterType((*MutateRowsRequest)(nil), "google.bigtable.v2.MutateRowsRequest")
	proto.RegisterType((*MutateRowsRequest_Entry)(nil), "google.bigtable.v2.MutateRowsRequest.Entry")
	proto.RegisterType((*MutateRowsResponse)(nil), "google.bigtable.v2.MutateRowsResponse")
	proto.RegisterType((*MutateRowsResponse_Entry)(nil), "google.bigtable.v2.MutateRowsResponse.Entry")
	proto.RegisterType((*CheckAndMutateRowRequest)(nil), "google.bigtable.v2.CheckAndMutateRowRequest")
	proto.RegisterType((*CheckAndMutateRowResponse)(nil), "google.bigtable.v2.CheckAndMutateRowResponse")
	proto.RegisterType((*ReadModifyWriteRowRequest)(nil), "google.bigtable.v2.ReadModifyWriteRowRequest")
	proto.RegisterType((*ReadModifyWriteRowResponse)(nil), "google.bigtable.v2.ReadModifyWriteRowResponse")
}

func init() { proto.RegisterFile("google/bigtable/v2/bigtable.proto", fileDescriptorBigtable) }

var fileDescriptorBigtable = []byte{
	// 1135 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0x67, 0xec, 0xda, 0xf5, 0xbe, 0x34, 0x4d, 0x32, 0x84, 0x66, 0x6b, 0x12, 0x70, 0x97, 0x16,
	0x1c, 0x97, 0xae, 0x2b, 0xa3, 0x1e, 0x6a, 0x94, 0x02, 0x36, 0xf9, 0x83, 0xc0, 0x55, 0x35, 0x96,
	0xc2, 0x25, 0x92, 0x35, 0x5e, 0x8f, 0x93, 0x25, 0xfb, 0xc7, 0xdd, 0x9d, 0x8d, 0x71, 0x11, 0x17,
	0x0e, 0x7c, 0x00, 0x38, 0x23, 0x4e, 0x08, 0x84, 0x04, 0x47, 0xae, 0x1c, 0xb8, 0x71, 0xe5, 0xc0,
	0x17, 0xe8, 0x27, 0xe0, 0x13, 0xa0, 0x99, 0x9d, 0xb5, 0x9d, 0xc4, 0x6e, 0x37, 0x55, 0x6f, 0x3b,
	0xef, 0xbd, 0xdf, 0x9b, 0xdf, 0xfb, 0x3b, 0x0b, 0x37, 0x0e, 0x7d, 0xff, 0xd0, 0x61, 0xd5, 0xae,
	0x7d, 0xc8, 0x69, 0xd7, 0x61, 0xd5, 0x93, 0xda, 0xf8, 0xdb, 0x1c, 0x04, 0x3e, 0xf7, 0x31, 0x8e,
	0x4d, 0xcc, 0xb1, 0xf8, 0xa4, 0x56, 0x5c, 0x57, 0x30, 0x3a, 0xb0, 0xab, 0xd4, 0xf3, 0x7c, 0x4e,
	0xb9, 0xed, 0x7b, 0x61, 0x8c, 0x28, 0x6e, 0xcc, 0x70, 0xda, 0xa3, 0x9c, 0x2a, 0xf5, 0x1b, 0x4a,
	0x2d, 0x4f, 0xdd, 0xa8, 0x5f, 0x1d, 0x06, 0x74, 0x30, 0x60, 0x41, 0x02, 0x5f, 0x53, 0xfa, 0x60,
	0x60, 0x55, 0x43, 0x4e, 0x79, 0xa4, 0x14, 0xc6, 0x1f, 0x08, 0x96, 0x08, 0xa3, 0x3d, 0xe2, 0x0f,
	0x43, 0xc2, 0x1e, 0x47, 0x2c, 0xe4, 0x78, 0x03, 0x40, 0xde, 0xd1, 0xf1, 0xa8, 0xcb, 0x74, 0x54,
	0x42, 0x65, 0x8d, 0x68, 0x52, 0xf2, 0x90, 0xba, 0x0c, 0x9b, 0x70, 0x29, 0xf0, 0x87, 0xa1, 0x9e,
	0x29, 0xa1, 0xf2, 0x42, 0xad, 0x68, 0x9e, 0x8f, 0xc5, 0x24, 0xfe, 0xb0, 0xcd, 0x38, 0x91, 0x76,
	0xf8, 0x1e, 0xe4, 0xfb, 0xb6, 0xc3, 0x59, 0xa0, 0x67, 0x25, 0x62, 0x63, 0x0e, 0x62, 0x47, 0x1a,
	0x11, 0x65, 0x2c, 0x58, 0x08, 0x78, 0xc7, 0xb1, 0x5d, 0x9b, 0xeb, 0x97, 0x4a, 0xa8, 0x9c, 0x25,
	0x9a, 0x90, 0x7c, 0x26, 0x04, 0xc6, 0x7f, 0x59, 0x58, 0x9e, 0x10, 0x0f, 0x07, 0xbe, 0x17, 0x32,
	0xbc, 0x03, 0x79, 0xeb, 0x28, 0xf2, 0x8e, 0x43, 0x1d, 0x95, 0xb2, 0xe5, 0x85, 0x9a, 0x39, 0xf3,
	0xaa, 0x33, 0x28, 0xb3, 0xc9, 0x1c, 0xa7, 0x29, 0x60, 0x44, 0xa1, 0x71, 0x15, 0x56, 0x1d, 0x1a,
	0xf2, 0x4e, 0x68, 0x51, 0xcf, 0x63, 0xbd, 0x4e, 0xe0, 0x0f, 0x3b, 0xc7, 0x6c, 0x24, 0x43, 0xbe,
	0x42, 0x56, 0x84, 0xae, 0x1d, 0xab, 0x88, 0x3f, 0xfc, 0x94, 0x8d, 0x8a, 0x4f, 0x33, 0xa0, 0x8d,
	0xdd, 0xe0, 0x35, 0xb8, 0x9c, 0x20, 0x90, 0x44, 0xe4, 0x03, 0x69, 0x86, 0xb7, 0x60, 0xa1, 0x4f,
	0x5d, 0xdb, 0x19, 0xc5, 0xa9, 0x8d, 0x33, 0xb8, 0x9e, 0x90, 0x4c, 0x8a, 0x67, 0xb6, 0x79, 0x60,
	0x7b, 0x87, 0xfb, 0xd4, 0x89, 0x18, 0x81, 0x18, 0x20, 0x33, 0x7f, 0x1f, 0xb4, 0xc7, 0x11, 0x75,
	0xec, 0xbe, 0x3d, 0x4e, 0xe6, 0xeb, 0xe7, 0xc0, 0x8d, 0x11, 0x67, 0x61, 0x8c, 0x9d, 0x58, 0xe3,
	0x4d, 0x58, 0xe6, 0xb6, 0xcb, 0x42, 0x4e, 0xdd, 0x41, 0xc7, 0xb5, 0xad, 0xc0, 0x0f, 0x55, 0x4e,
	0x97, 0xc6, 0xf2, 0x96, 0x14, 0xe3, 0x6b, 0x90, 0x77, 0x68, 0x97, 0x39, 0xa1, 0x9e, 0x2b, 0x65,
	0xcb, 0x1a, 0x51, 0x27, 0xbc, 0x0a, 0xb9, 0x13, 0xe1, 0x56, 0xcf, 0xcb, 0x98, 0xe2, 0x83, 0x28,
	0x93, 0xfc, 0xe8, 0x84, 0xf6, 0x13, 0xa6, 0x5f, 0x2e, 0xa1, 0x72, 0x8e, 0x68, 0x52, 0xd2, 0xb6,
	0x9f, 0x08, 0xb5, 0x16, 0xb0, 0x90, 0x71, 0x91, 0x42, 0xbd, 0x50, 0x42, 0xe5, 0xc2, 0xde, 0x2b,
	0xa4, 0x20, 0x45, 0xc4, 0x1f, 0xe2, 0x37, 0x01, 0x2c, 0xdf, 0x75, 0xed, 0x58, 0xaf, 0x29, 0xbd,
	0x16, 0xcb, 0x88, 0x3f, 0x6c, 0x5c, 0x91, 0x5d, 0xd0, 0x89, 0x7b, 0xd6, 0xb8, 0x07, 0xab, 0x6d,
	0xea, 0x0e, 0x1c, 0x16, 0xa7, 0x3d, 0x65, 0xc7, 0x1a, 0x6d, 0x78, 0xed, 0x0c, 0x4c, 0xf5, 0xcb,
	0xdc, 0x42, 0xdd, 0x80, 0x2b, 0x7e, 0xbf, 0x2f, 0x78, 0x77, 0x45, 0x3a, 0x65, 0xa5, 0xb2, 0x64,
	0x21, 0x96, 0xc9, 0x0c, 0x1b, 0xdf, 0x22, 0x58, 0x6e, 0x45, 0x9c, 0x72, 0xe1, 0x35, 0xe5, 0xe8,
	0x4c, 0xdd, 0x97, 0x39, 0x75, 0x5f, 0x1d, 0x34, 0x37, 0x52, 0x13, 0xaf, 0x67, 0x65, 0xef, 0xae,
	0xcf, 0xea, 0xdd, 0x96, 0x32, 0x22, 0x13, 0x73, 0xe3, 0x55, 0x58, 0x99, 0xe2, 0x11, 0x47, 0x66,
	0xfc, 0x8b, 0xa6, 0xa4, 0x69, 0x27, 0x7b, 0x1b, 0x2e, 0x33, 0x8f, 0x07, 0xb6, 0x0c, 0x58, 0x70,
	0xb8, 0x3d, 0x97, 0xc3, 0xb4, 0x5b, 0x73, 0xdb, 0xe3, 0xc1, 0x88, 0x24, 0xd8, 0xe2, 0x01, 0xe4,
	0xa4, 0x64, 0x7e, 0x7a, 0x4f, 0x85, 0x9b, 0xb9, 0x58, 0xb8, 0x3f, 0x23, 0xc0, 0xd3, 0x14, 0xc6,
	0xa3, 0x3f, 0xe6, 0x1e, 0xcf, 0xfe, 0xbb, 0xcf, 0xe3, 0xae, 0xa6, 0xff, 0x0c, 0xf9, 0x4f, 0x12,
	0xf2, 0xab, 0x90, 0xb3, 0xbd, 0x1e, 0xfb, 0x52, 0x52, 0xcf, 0x92, 0xf8, 0x80, 0x2b, 0x90, 0x8f,
	0x7b, 0x51, 0x0d, 0x2f, 0x4e, 0x6e, 0x09, 0x06, 0x96, 0xd9, 0x96, 0x1a, 0xa2, 0x2c, 0x8c, 0x5f,
	0x32, 0xa0, 0x37, 0x8f, 0x98, 0x75, 0xfc, 0x91, 0xd7, 0x7b, 0x69, 0x9d, 0xb2, 0x07, 0xcb, 0x83,
	0x80, 0xf5, 0x6c, 0x8b, 0x72, 0xd6, 0x51, 0x7b, 0x35, 0x9f, 0x66, 0xaf, 0x2e, 0x8d, 0x61, 0xb1,
	0x00, 0x37, 0xe1, 0x2a, 0x0f, 0x22, 0xd6, 0x99, 0x54, 0xe2, 0x52, 0x8a, 0x4a, 0x2c, 0x0a, 0x4c,
	0x72, 0x0a, 0xf1, 0x36, 0x2c, 0xf5, 0xa9, 0x13, 0x4e, 0x7b, 0xc9, 0xa5, 0xf0, 0x72, 0x55, 0x82,
	0xc6, 0x6e, 0x8c, 0x3d, 0xb8, 0x3e, 0x23, 0x53, 0xaa, 0xb4, 0xb7, 0x61, 0x65, 0x12, 0xb2, 0x4b,
	0xb9, 0x75, 0xc4, 0x7a, 0x32, 0x63, 0x05, 0x32, 0xc9, 0x45, 0x2b, 0x96, 0x1b, 0xdf, 0x21, 0xb8,
	0x2e, 0x36, 0x7c, 0xcb, 0xef, 0xd9, 0xfd, 0xd1, 0xe7, 0x81, 0xfd, 0x52, 0xb2, 0xbe, 0x05, 0xb9,
	0x20, 0x72, 0x58, 0x32, 0x9b, 0xef, 0xcc, 0x7b, 0x57, 0xa6, 0x6f, 0x8d, 0x1c, 0x46, 0x62, 0x94,
	0xb1, 0x0b, 0xc5, 0x59, 0x9c, 0x54, 0x7c, 0x9b, 0x90, 0x15, 0xdb, 0x0f, 0xc9, 0x2a, 0xae, 0xcd,
	0xa9, 0x22, 0x11, 0x36, 0xb5, 0xdf, 0x0a, 0x50, 0x68, 0x28, 0x05, 0xfe, 0x01, 0x41, 0x21, 0x79,
	0xcc, 0xf0, 0x5b, 0xcf, 0x7e, 0xea, 0x64, 0xf8, 0xc5, 0x9b, 0x69, 0xde, 0x43, 0xe3, 0xe3, 0x6f,
	0xfe, 0x79, 0xfa, 0x7d, 0xe6, 0x81, 0x71, 0x5f, 0xfc, 0x64, 0x7c, 0x35, 0xc9, 0xd7, 0xd6, 0x20,
	0xf0, 0xbf, 0x60, 0x16, 0x0f, 0xab, 0x95, 0xaa, 0xed, 0x85, 0x9c, 0x7a, 0x16, 0x13, 0xdf, 0xd2,
	0x22, 0xac, 0x56, 0xbe, 0xae, 0x07, 0xca, 0x55, 0x1d, 0x55, 0xee, 0x22, 0xfc, 0x3b, 0x82, 0xc5,
	0x53, 0x7b, 0x17, 0x97, 0x67, 0xdd, 0x3f, 0x6b, 0xa3, 0x17, 0x37, 0x53, 0x58, 0x2a, 0xba, 0x3b,
	0x92, 0xee, 0x87, 0xf8, 0xc1, 0x85, 0xe9, 0x86, 0xd3, 0xfe, 0xee, 0x22, 0xfc, 0x23, 0x02, 0x6d,
	0xdc, 0x7e, 0xf8, 0xe6, 0x33, 0x17, 0x48, 0x42, 0xf4, 0xd6, 0x73, 0xac, 0x14, 0xc9, 0x6d, 0x49,
	0xf2, 0x03, 0xa3, 0x7e, 0x61, 0x92, 0x6e, 0xe2, 0xab, 0x8e, 0x2a, 0xf8, 0x27, 0x04, 0x30, 0xd9,
	0x61, 0xf8, 0x56, 0xaa, 0xfd, 0x5c, 0x7c, 0x3b, 0xdd, 0x2a, 0x4c, 0x32, 0x69, 0xbc, 0xff, 0xe2,
	0x24, 0x55, 0xe9, 0xff, 0x44, 0xb0, 0x72, 0x6e, 0xa0, 0xf1, 0xcc, 0x95, 0x3c, 0x6f, 0x43, 0x16,
	0xef, 0xa4, 0xb4, 0x56, 0xe4, 0x5b, 0x92, 0xfc, 0xae, 0xd1, 0xb8, 0x30, 0x79, 0xeb, 0xac, 0x4f,
	0x91, 0xe9, 0xbf, 0x10, 0xe0, 0xf3, 0x33, 0x8b, 0xef, 0xa4, 0x99, 0xfc, 0x49, 0x0c, 0x66, 0x5a,
	0x73, 0x15, 0xc4, 0x43, 0x19, 0xc4, 0x9e, 0xd1, 0x7c, 0xa1, 0xd1, 0x3b, 0xed, 0xb4, 0x8e, 0x2a,
	0x8d, 0x0e, 0x5c, 0xb3, 0x7c, 0x77, 0x06, 0x89, 0xc6, 0x62, 0xb2, 0x46, 0x1e, 0x89, 0x1f, 0xc7,
	0x47, 0xe8, 0xd7, 0x8c, 0xbe, 0x1b, 0x5b, 0x35, 0x1d, 0x3f, 0xea, 0x99, 0x89, 0xda, 0xdc, 0xaf,
	0xfd, 0x9d, 0xa8, 0x0e, 0xa4, 0xea, 0x20, 0x51, 0x1d, 0xec, 0xd7, 0xba, 0x79, 0xf9, 0xdf, 0xf9,
	0xde, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x12, 0x7e, 0x5b, 0xfd, 0xf5, 0x0c, 0x00, 0x00,
}
