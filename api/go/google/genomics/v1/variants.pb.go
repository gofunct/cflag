// Code generated by protoc-gen-go. DO NOT EDIT.
// source: google/genomics/v1/variants.proto

package google_genomics_v1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "go.pedge.io/pb/go/google/api"
import _ "go.pedge.io/pb/go/google/longrunning"
import _ "github.com/golang/protobuf/ptypes/empty"
import google_protobuf2 "go.pedge.io/pb/go/google/protobuf"
import google_protobuf3 "github.com/golang/protobuf/ptypes/struct"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Operations to be performed during import on Variant info fields.
// These operations are set for each info field in the info_merge_config
// map of ImportVariantsRequest, which is plumbed down to the
// MergeVariantRequests generated by the import job.
type InfoMergeOperation int32

const (
	InfoMergeOperation_INFO_MERGE_OPERATION_UNSPECIFIED InfoMergeOperation = 0
	// By default, Variant info fields are persisted if the Variant doesn't
	// already exist in the variantset.  If the Variant is equivalent to a
	// Variant already in the variantset, the incoming Variant's info field
	// is ignored in favor of that of the already persisted Variant.
	InfoMergeOperation_IGNORE_NEW InfoMergeOperation = 1
	// This operation removes an info field from the incoming Variant
	// and persists this info field in each of the incoming Variant's Calls.
	InfoMergeOperation_MOVE_TO_CALLS InfoMergeOperation = 2
)

var InfoMergeOperation_name = map[int32]string{
	0: "INFO_MERGE_OPERATION_UNSPECIFIED",
	1: "IGNORE_NEW",
	2: "MOVE_TO_CALLS",
}
var InfoMergeOperation_value = map[string]int32{
	"INFO_MERGE_OPERATION_UNSPECIFIED": 0,
	"IGNORE_NEW":                       1,
	"MOVE_TO_CALLS":                    2,
}

func (x InfoMergeOperation) String() string {
	return proto.EnumName(InfoMergeOperation_name, int32(x))
}
func (InfoMergeOperation) EnumDescriptor() ([]byte, []int) { return fileDescriptor11, []int{0} }

type VariantSetMetadata_Type int32

const (
	VariantSetMetadata_TYPE_UNSPECIFIED VariantSetMetadata_Type = 0
	VariantSetMetadata_INTEGER          VariantSetMetadata_Type = 1
	VariantSetMetadata_FLOAT            VariantSetMetadata_Type = 2
	VariantSetMetadata_FLAG             VariantSetMetadata_Type = 3
	VariantSetMetadata_CHARACTER        VariantSetMetadata_Type = 4
	VariantSetMetadata_STRING           VariantSetMetadata_Type = 5
)

var VariantSetMetadata_Type_name = map[int32]string{
	0: "TYPE_UNSPECIFIED",
	1: "INTEGER",
	2: "FLOAT",
	3: "FLAG",
	4: "CHARACTER",
	5: "STRING",
}
var VariantSetMetadata_Type_value = map[string]int32{
	"TYPE_UNSPECIFIED": 0,
	"INTEGER":          1,
	"FLOAT":            2,
	"FLAG":             3,
	"CHARACTER":        4,
	"STRING":           5,
}

func (x VariantSetMetadata_Type) String() string {
	return proto.EnumName(VariantSetMetadata_Type_name, int32(x))
}
func (VariantSetMetadata_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor11, []int{0, 0} }

type ImportVariantsRequest_Format int32

const (
	ImportVariantsRequest_FORMAT_UNSPECIFIED ImportVariantsRequest_Format = 0
	// VCF (Variant Call Format). The VCF files may be gzip compressed. gVCF is
	// also supported.
	ImportVariantsRequest_FORMAT_VCF ImportVariantsRequest_Format = 1
	// Complete Genomics masterVarBeta format. The masterVarBeta files may
	// be bzip2 compressed.
	ImportVariantsRequest_FORMAT_COMPLETE_GENOMICS ImportVariantsRequest_Format = 2
)

var ImportVariantsRequest_Format_name = map[int32]string{
	0: "FORMAT_UNSPECIFIED",
	1: "FORMAT_VCF",
	2: "FORMAT_COMPLETE_GENOMICS",
}
var ImportVariantsRequest_Format_value = map[string]int32{
	"FORMAT_UNSPECIFIED":       0,
	"FORMAT_VCF":               1,
	"FORMAT_COMPLETE_GENOMICS": 2,
}

func (x ImportVariantsRequest_Format) String() string {
	return proto.EnumName(ImportVariantsRequest_Format_name, int32(x))
}
func (ImportVariantsRequest_Format) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor11, []int{6, 0}
}

type ExportVariantSetRequest_Format int32

const (
	ExportVariantSetRequest_FORMAT_UNSPECIFIED ExportVariantSetRequest_Format = 0
	// Export the data to Google BigQuery.
	ExportVariantSetRequest_FORMAT_BIGQUERY ExportVariantSetRequest_Format = 1
)

var ExportVariantSetRequest_Format_name = map[int32]string{
	0: "FORMAT_UNSPECIFIED",
	1: "FORMAT_BIGQUERY",
}
var ExportVariantSetRequest_Format_value = map[string]int32{
	"FORMAT_UNSPECIFIED": 0,
	"FORMAT_BIGQUERY":    1,
}

func (x ExportVariantSetRequest_Format) String() string {
	return proto.EnumName(ExportVariantSetRequest_Format_name, int32(x))
}
func (ExportVariantSetRequest_Format) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor11, []int{9, 0}
}

// Metadata describes a single piece of variant call metadata.
// These data include a top level key and either a single value string (value)
// or a list of key-value pairs (info.)
// Value and info are mutually exclusive.
type VariantSetMetadata struct {
	// The top-level key.
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// The value field for simple metadata
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	// User-provided ID field, not enforced by this API.
	// Two or more pieces of structured metadata with identical
	// id and key fields are considered equivalent.
	Id string `protobuf:"bytes,4,opt,name=id" json:"id,omitempty"`
	// The type of data. Possible types include: Integer, Float,
	// Flag, Character, and String.
	Type VariantSetMetadata_Type `protobuf:"varint,5,opt,name=type,enum=google.genomics.v1.VariantSetMetadata_Type" json:"type,omitempty"`
	// The number of values that can be included in a field described by this
	// metadata.
	Number string `protobuf:"bytes,8,opt,name=number" json:"number,omitempty"`
	// A textual description of this metadata.
	Description string `protobuf:"bytes,7,opt,name=description" json:"description,omitempty"`
	// Remaining structured metadata key-value pairs. This must be of the form
	// map<string, string[]> (string key mapping to a list of string values).
	Info map[string]*google_protobuf3.ListValue `protobuf:"bytes,3,rep,name=info" json:"info,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *VariantSetMetadata) Reset()                    { *m = VariantSetMetadata{} }
func (m *VariantSetMetadata) String() string            { return proto.CompactTextString(m) }
func (*VariantSetMetadata) ProtoMessage()               {}
func (*VariantSetMetadata) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{0} }

func (m *VariantSetMetadata) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *VariantSetMetadata) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *VariantSetMetadata) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *VariantSetMetadata) GetType() VariantSetMetadata_Type {
	if m != nil {
		return m.Type
	}
	return VariantSetMetadata_TYPE_UNSPECIFIED
}

func (m *VariantSetMetadata) GetNumber() string {
	if m != nil {
		return m.Number
	}
	return ""
}

func (m *VariantSetMetadata) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *VariantSetMetadata) GetInfo() map[string]*google_protobuf3.ListValue {
	if m != nil {
		return m.Info
	}
	return nil
}

// A variant set is a collection of call sets and variants. It contains summary
// statistics of those contents. A variant set belongs to a dataset.
//
// For more genomics resource definitions, see [Fundamentals of Google
// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
type VariantSet struct {
	// The dataset to which this variant set belongs.
	DatasetId string `protobuf:"bytes,1,opt,name=dataset_id,json=datasetId" json:"dataset_id,omitempty"`
	// The server-generated variant set ID, unique across all variant sets.
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// The reference set to which the variant set is mapped. The reference set
	// describes the alignment provenance of the variant set, while the
	// `referenceBounds` describe the shape of the actual variant data. The
	// reference set's reference names are a superset of those found in the
	// `referenceBounds`.
	//
	// For example, given a variant set that is mapped to the GRCh38 reference set
	// and contains a single variant on reference 'X', `referenceBounds` would
	// contain only an entry for 'X', while the associated reference set
	// enumerates all possible references: '1', '2', 'X', 'Y', 'MT', etc.
	ReferenceSetId string `protobuf:"bytes,6,opt,name=reference_set_id,json=referenceSetId" json:"reference_set_id,omitempty"`
	// A list of all references used by the variants in a variant set
	// with associated coordinate upper bounds for each one.
	ReferenceBounds []*ReferenceBound `protobuf:"bytes,5,rep,name=reference_bounds,json=referenceBounds" json:"reference_bounds,omitempty"`
	// The metadata associated with this variant set.
	Metadata []*VariantSetMetadata `protobuf:"bytes,4,rep,name=metadata" json:"metadata,omitempty"`
	// User-specified, mutable name.
	Name string `protobuf:"bytes,7,opt,name=name" json:"name,omitempty"`
	// A textual description of this variant set.
	Description string `protobuf:"bytes,8,opt,name=description" json:"description,omitempty"`
}

func (m *VariantSet) Reset()                    { *m = VariantSet{} }
func (m *VariantSet) String() string            { return proto.CompactTextString(m) }
func (*VariantSet) ProtoMessage()               {}
func (*VariantSet) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{1} }

func (m *VariantSet) GetDatasetId() string {
	if m != nil {
		return m.DatasetId
	}
	return ""
}

func (m *VariantSet) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *VariantSet) GetReferenceSetId() string {
	if m != nil {
		return m.ReferenceSetId
	}
	return ""
}

func (m *VariantSet) GetReferenceBounds() []*ReferenceBound {
	if m != nil {
		return m.ReferenceBounds
	}
	return nil
}

func (m *VariantSet) GetMetadata() []*VariantSetMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *VariantSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VariantSet) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// A variant represents a change in DNA sequence relative to a reference
// sequence. For example, a variant could represent a SNP or an insertion.
// Variants belong to a variant set.
//
// For more genomics resource definitions, see [Fundamentals of Google
// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
//
// Each of the calls on a variant represent a determination of genotype with
// respect to that variant. For example, a call might assign probability of 0.32
// to the occurrence of a SNP named rs1234 in a sample named NA12345. A call
// belongs to a call set, which contains related calls typically from one
// sample.
type Variant struct {
	// The ID of the variant set this variant belongs to.
	VariantSetId string `protobuf:"bytes,15,opt,name=variant_set_id,json=variantSetId" json:"variant_set_id,omitempty"`
	// The server-generated variant ID, unique across all variants.
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// Names for the variant, for example a RefSNP ID.
	Names []string `protobuf:"bytes,3,rep,name=names" json:"names,omitempty"`
	// The date this variant was created, in milliseconds from the epoch.
	Created int64 `protobuf:"varint,12,opt,name=created" json:"created,omitempty"`
	// The reference on which this variant occurs.
	// (such as `chr20` or `X`)
	ReferenceName string `protobuf:"bytes,14,opt,name=reference_name,json=referenceName" json:"reference_name,omitempty"`
	// The position at which this variant occurs (0-based).
	// This corresponds to the first base of the string of reference bases.
	Start int64 `protobuf:"varint,16,opt,name=start" json:"start,omitempty"`
	// The end position (0-based) of this variant. This corresponds to the first
	// base after the last base in the reference allele. So, the length of
	// the reference allele is (end - start). This is useful for variants
	// that don't explicitly give alternate bases, for example large deletions.
	End int64 `protobuf:"varint,13,opt,name=end" json:"end,omitempty"`
	// The reference bases for this variant. They start at the given
	// position.
	ReferenceBases string `protobuf:"bytes,6,opt,name=reference_bases,json=referenceBases" json:"reference_bases,omitempty"`
	// The bases that appear instead of the reference bases.
	AlternateBases []string `protobuf:"bytes,7,rep,name=alternate_bases,json=alternateBases" json:"alternate_bases,omitempty"`
	// A measure of how likely this variant is to be real.
	// A higher value is better.
	Quality float64 `protobuf:"fixed64,8,opt,name=quality" json:"quality,omitempty"`
	// A list of filters (normally quality filters) this variant has failed.
	// `PASS` indicates this variant has passed all filters.
	Filter []string `protobuf:"bytes,9,rep,name=filter" json:"filter,omitempty"`
	// A map of additional variant information. This must be of the form
	// map<string, string[]> (string key mapping to a list of string values).
	Info map[string]*google_protobuf3.ListValue `protobuf:"bytes,10,rep,name=info" json:"info,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The variant calls for this particular variant. Each one represents the
	// determination of genotype with respect to this variant.
	Calls []*VariantCall `protobuf:"bytes,11,rep,name=calls" json:"calls,omitempty"`
}

func (m *Variant) Reset()                    { *m = Variant{} }
func (m *Variant) String() string            { return proto.CompactTextString(m) }
func (*Variant) ProtoMessage()               {}
func (*Variant) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{2} }

func (m *Variant) GetVariantSetId() string {
	if m != nil {
		return m.VariantSetId
	}
	return ""
}

func (m *Variant) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Variant) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

func (m *Variant) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *Variant) GetReferenceName() string {
	if m != nil {
		return m.ReferenceName
	}
	return ""
}

func (m *Variant) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Variant) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *Variant) GetReferenceBases() string {
	if m != nil {
		return m.ReferenceBases
	}
	return ""
}

func (m *Variant) GetAlternateBases() []string {
	if m != nil {
		return m.AlternateBases
	}
	return nil
}

func (m *Variant) GetQuality() float64 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *Variant) GetFilter() []string {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *Variant) GetInfo() map[string]*google_protobuf3.ListValue {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Variant) GetCalls() []*VariantCall {
	if m != nil {
		return m.Calls
	}
	return nil
}

// A call represents the determination of genotype with respect to a particular
// variant. It may include associated information such as quality and phasing.
// For example, a call might assign a probability of 0.32 to the occurrence of
// a SNP named rs1234 in a call set with the name NA12345.
type VariantCall struct {
	// The ID of the call set this variant call belongs to.
	CallSetId string `protobuf:"bytes,8,opt,name=call_set_id,json=callSetId" json:"call_set_id,omitempty"`
	// The name of the call set this variant call belongs to.
	CallSetName string `protobuf:"bytes,9,opt,name=call_set_name,json=callSetName" json:"call_set_name,omitempty"`
	// The genotype of this variant call. Each value represents either the value
	// of the `referenceBases` field or a 1-based index into
	// `alternateBases`. If a variant had a `referenceBases`
	// value of `T` and an `alternateBases`
	// value of `["A", "C"]`, and the `genotype` was
	// `[2, 1]`, that would mean the call
	// represented the heterozygous value `CA` for this variant.
	// If the `genotype` was instead `[0, 1]`, the
	// represented value would be `TA`. Ordering of the
	// genotype values is important if the `phaseset` is present.
	// If a genotype is not called (that is, a `.` is present in the
	// GT string) -1 is returned.
	Genotype []int32 `protobuf:"varint,7,rep,packed,name=genotype" json:"genotype,omitempty"`
	// If this field is present, this variant call's genotype ordering implies
	// the phase of the bases and is consistent with any other variant calls in
	// the same reference sequence which have the same phaseset value.
	// When importing data from VCF, if the genotype data was phased but no
	// phase set was specified this field will be set to `*`.
	Phaseset string `protobuf:"bytes,5,opt,name=phaseset" json:"phaseset,omitempty"`
	// The genotype likelihoods for this variant call. Each array entry
	// represents how likely a specific genotype is for this call. The value
	// ordering is defined by the GL tag in the VCF spec.
	// If Phred-scaled genotype likelihood scores (PL) are available and
	// log10(P) genotype likelihood scores (GL) are not, PL scores are converted
	// to GL scores.  If both are available, PL scores are stored in `info`.
	GenotypeLikelihood []float64 `protobuf:"fixed64,6,rep,packed,name=genotype_likelihood,json=genotypeLikelihood" json:"genotype_likelihood,omitempty"`
	// A map of additional variant call information. This must be of the form
	// map<string, string[]> (string key mapping to a list of string values).
	Info map[string]*google_protobuf3.ListValue `protobuf:"bytes,2,rep,name=info" json:"info,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *VariantCall) Reset()                    { *m = VariantCall{} }
func (m *VariantCall) String() string            { return proto.CompactTextString(m) }
func (*VariantCall) ProtoMessage()               {}
func (*VariantCall) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{3} }

func (m *VariantCall) GetCallSetId() string {
	if m != nil {
		return m.CallSetId
	}
	return ""
}

func (m *VariantCall) GetCallSetName() string {
	if m != nil {
		return m.CallSetName
	}
	return ""
}

func (m *VariantCall) GetGenotype() []int32 {
	if m != nil {
		return m.Genotype
	}
	return nil
}

func (m *VariantCall) GetPhaseset() string {
	if m != nil {
		return m.Phaseset
	}
	return ""
}

func (m *VariantCall) GetGenotypeLikelihood() []float64 {
	if m != nil {
		return m.GenotypeLikelihood
	}
	return nil
}

func (m *VariantCall) GetInfo() map[string]*google_protobuf3.ListValue {
	if m != nil {
		return m.Info
	}
	return nil
}

// A call set is a collection of variant calls, typically for one sample. It
// belongs to a variant set.
//
// For more genomics resource definitions, see [Fundamentals of Google
// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
type CallSet struct {
	// The server-generated call set ID, unique across all call sets.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The call set name.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The sample ID this call set corresponds to.
	SampleId string `protobuf:"bytes,7,opt,name=sample_id,json=sampleId" json:"sample_id,omitempty"`
	// The IDs of the variant sets this call set belongs to. This field must
	// have exactly length one, as a call set belongs to a single variant set.
	// This field is repeated for compatibility with the
	// [GA4GH 0.5.1
	// API](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variants.avdl#L76).
	VariantSetIds []string `protobuf:"bytes,6,rep,name=variant_set_ids,json=variantSetIds" json:"variant_set_ids,omitempty"`
	// The date this call set was created in milliseconds from the epoch.
	Created int64 `protobuf:"varint,5,opt,name=created" json:"created,omitempty"`
	// A map of additional call set information. This must be of the form
	// map<string, string[]> (string key mapping to a list of string values).
	Info map[string]*google_protobuf3.ListValue `protobuf:"bytes,4,rep,name=info" json:"info,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *CallSet) Reset()                    { *m = CallSet{} }
func (m *CallSet) String() string            { return proto.CompactTextString(m) }
func (*CallSet) ProtoMessage()               {}
func (*CallSet) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{4} }

func (m *CallSet) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CallSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CallSet) GetSampleId() string {
	if m != nil {
		return m.SampleId
	}
	return ""
}

func (m *CallSet) GetVariantSetIds() []string {
	if m != nil {
		return m.VariantSetIds
	}
	return nil
}

func (m *CallSet) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *CallSet) GetInfo() map[string]*google_protobuf3.ListValue {
	if m != nil {
		return m.Info
	}
	return nil
}

// ReferenceBound records an upper bound for the starting coordinate of
// variants in a particular reference.
type ReferenceBound struct {
	// The name of the reference associated with this reference bound.
	ReferenceName string `protobuf:"bytes,1,opt,name=reference_name,json=referenceName" json:"reference_name,omitempty"`
	// An upper bound (inclusive) on the starting coordinate of any
	// variant in the reference sequence.
	UpperBound int64 `protobuf:"varint,2,opt,name=upper_bound,json=upperBound" json:"upper_bound,omitempty"`
}

func (m *ReferenceBound) Reset()                    { *m = ReferenceBound{} }
func (m *ReferenceBound) String() string            { return proto.CompactTextString(m) }
func (*ReferenceBound) ProtoMessage()               {}
func (*ReferenceBound) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{5} }

func (m *ReferenceBound) GetReferenceName() string {
	if m != nil {
		return m.ReferenceName
	}
	return ""
}

func (m *ReferenceBound) GetUpperBound() int64 {
	if m != nil {
		return m.UpperBound
	}
	return 0
}

// The variant data import request.
type ImportVariantsRequest struct {
	// Required. The variant set to which variant data should be imported.
	VariantSetId string `protobuf:"bytes,1,opt,name=variant_set_id,json=variantSetId" json:"variant_set_id,omitempty"`
	// A list of URIs referencing variant files in Google Cloud Storage. URIs can
	// include wildcards [as described
	// here](https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames).
	// Note that recursive wildcards ('**') are not supported.
	SourceUris []string `protobuf:"bytes,2,rep,name=source_uris,json=sourceUris" json:"source_uris,omitempty"`
	// The format of the variant data being imported. If unspecified, defaults to
	// to `VCF`.
	Format ImportVariantsRequest_Format `protobuf:"varint,3,opt,name=format,enum=google.genomics.v1.ImportVariantsRequest_Format" json:"format,omitempty"`
	// Convert reference names to the canonical representation.
	// hg19 haploytypes (those reference names containing "_hap")
	// are not modified in any way.
	// All other reference names are modified according to the following rules:
	// The reference name is capitalized.
	// The "chr" prefix is dropped for all autosomes and sex chromsomes.
	// For example "chr17" becomes "17" and "chrX" becomes "X".
	// All mitochondrial chromosomes ("chrM", "chrMT", etc) become "MT".
	NormalizeReferenceNames bool `protobuf:"varint,5,opt,name=normalize_reference_names,json=normalizeReferenceNames" json:"normalize_reference_names,omitempty"`
	// A mapping between info field keys and the InfoMergeOperations to
	// be performed on them. This is plumbed down to the MergeVariantRequests
	// generated by the resulting import job.
	InfoMergeConfig map[string]InfoMergeOperation `protobuf:"bytes,6,rep,name=info_merge_config,json=infoMergeConfig" json:"info_merge_config,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value,enum=google.genomics.v1.InfoMergeOperation"`
}

func (m *ImportVariantsRequest) Reset()                    { *m = ImportVariantsRequest{} }
func (m *ImportVariantsRequest) String() string            { return proto.CompactTextString(m) }
func (*ImportVariantsRequest) ProtoMessage()               {}
func (*ImportVariantsRequest) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{6} }

func (m *ImportVariantsRequest) GetVariantSetId() string {
	if m != nil {
		return m.VariantSetId
	}
	return ""
}

func (m *ImportVariantsRequest) GetSourceUris() []string {
	if m != nil {
		return m.SourceUris
	}
	return nil
}

func (m *ImportVariantsRequest) GetFormat() ImportVariantsRequest_Format {
	if m != nil {
		return m.Format
	}
	return ImportVariantsRequest_FORMAT_UNSPECIFIED
}

func (m *ImportVariantsRequest) GetNormalizeReferenceNames() bool {
	if m != nil {
		return m.NormalizeReferenceNames
	}
	return false
}

func (m *ImportVariantsRequest) GetInfoMergeConfig() map[string]InfoMergeOperation {
	if m != nil {
		return m.InfoMergeConfig
	}
	return nil
}

// The variant data import response.
type ImportVariantsResponse struct {
	// IDs of the call sets created during the import.
	CallSetIds []string `protobuf:"bytes,1,rep,name=call_set_ids,json=callSetIds" json:"call_set_ids,omitempty"`
}

func (m *ImportVariantsResponse) Reset()                    { *m = ImportVariantsResponse{} }
func (m *ImportVariantsResponse) String() string            { return proto.CompactTextString(m) }
func (*ImportVariantsResponse) ProtoMessage()               {}
func (*ImportVariantsResponse) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{7} }

func (m *ImportVariantsResponse) GetCallSetIds() []string {
	if m != nil {
		return m.CallSetIds
	}
	return nil
}

// The CreateVariantSet request
type CreateVariantSetRequest struct {
	// Required. The variant set to be created. Must have a valid `datasetId`.
	VariantSet *VariantSet `protobuf:"bytes,1,opt,name=variant_set,json=variantSet" json:"variant_set,omitempty"`
}

func (m *CreateVariantSetRequest) Reset()                    { *m = CreateVariantSetRequest{} }
func (m *CreateVariantSetRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateVariantSetRequest) ProtoMessage()               {}
func (*CreateVariantSetRequest) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{8} }

func (m *CreateVariantSetRequest) GetVariantSet() *VariantSet {
	if m != nil {
		return m.VariantSet
	}
	return nil
}

// The variant data export request.
type ExportVariantSetRequest struct {
	// Required. The ID of the variant set that contains variant data which
	// should be exported. The caller must have READ access to this variant set.
	VariantSetId string `protobuf:"bytes,1,opt,name=variant_set_id,json=variantSetId" json:"variant_set_id,omitempty"`
	// If provided, only variant call information from the specified call sets
	// will be exported. By default all variant calls are exported.
	CallSetIds []string `protobuf:"bytes,2,rep,name=call_set_ids,json=callSetIds" json:"call_set_ids,omitempty"`
	// Required. The Google Cloud project ID that owns the destination
	// BigQuery dataset. The caller must have WRITE access to this project.  This
	// project will also own the resulting export job.
	ProjectId string `protobuf:"bytes,3,opt,name=project_id,json=projectId" json:"project_id,omitempty"`
	// The format for the exported data.
	Format ExportVariantSetRequest_Format `protobuf:"varint,4,opt,name=format,enum=google.genomics.v1.ExportVariantSetRequest_Format" json:"format,omitempty"`
	// Required. The BigQuery dataset to export data to. This dataset must already
	// exist. Note that this is distinct from the Genomics concept of "dataset".
	BigqueryDataset string `protobuf:"bytes,5,opt,name=bigquery_dataset,json=bigqueryDataset" json:"bigquery_dataset,omitempty"`
	// Required. The BigQuery table to export data to.
	// If the table doesn't exist, it will be created. If it already exists, it
	// will be overwritten.
	BigqueryTable string `protobuf:"bytes,6,opt,name=bigquery_table,json=bigqueryTable" json:"bigquery_table,omitempty"`
}

func (m *ExportVariantSetRequest) Reset()                    { *m = ExportVariantSetRequest{} }
func (m *ExportVariantSetRequest) String() string            { return proto.CompactTextString(m) }
func (*ExportVariantSetRequest) ProtoMessage()               {}
func (*ExportVariantSetRequest) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{9} }

func (m *ExportVariantSetRequest) GetVariantSetId() string {
	if m != nil {
		return m.VariantSetId
	}
	return ""
}

func (m *ExportVariantSetRequest) GetCallSetIds() []string {
	if m != nil {
		return m.CallSetIds
	}
	return nil
}

func (m *ExportVariantSetRequest) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *ExportVariantSetRequest) GetFormat() ExportVariantSetRequest_Format {
	if m != nil {
		return m.Format
	}
	return ExportVariantSetRequest_FORMAT_UNSPECIFIED
}

func (m *ExportVariantSetRequest) GetBigqueryDataset() string {
	if m != nil {
		return m.BigqueryDataset
	}
	return ""
}

func (m *ExportVariantSetRequest) GetBigqueryTable() string {
	if m != nil {
		return m.BigqueryTable
	}
	return ""
}

// The variant set request.
type GetVariantSetRequest struct {
	// Required. The ID of the variant set.
	VariantSetId string `protobuf:"bytes,1,opt,name=variant_set_id,json=variantSetId" json:"variant_set_id,omitempty"`
}

func (m *GetVariantSetRequest) Reset()                    { *m = GetVariantSetRequest{} }
func (m *GetVariantSetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetVariantSetRequest) ProtoMessage()               {}
func (*GetVariantSetRequest) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{10} }

func (m *GetVariantSetRequest) GetVariantSetId() string {
	if m != nil {
		return m.VariantSetId
	}
	return ""
}

// The search variant sets request.
type SearchVariantSetsRequest struct {
	// Exactly one dataset ID must be provided here. Only variant sets which
	// belong to this dataset will be returned.
	DatasetIds []string `protobuf:"bytes,1,rep,name=dataset_ids,json=datasetIds" json:"dataset_ids,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// To get the next page of results, set this parameter to the value of
	// `nextPageToken` from the previous response.
	PageToken string `protobuf:"bytes,2,opt,name=page_token,json=pageToken" json:"page_token,omitempty"`
	// The maximum number of results to return in a single page. If unspecified,
	// defaults to 1024.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
}

func (m *SearchVariantSetsRequest) Reset()                    { *m = SearchVariantSetsRequest{} }
func (m *SearchVariantSetsRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchVariantSetsRequest) ProtoMessage()               {}
func (*SearchVariantSetsRequest) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{11} }

func (m *SearchVariantSetsRequest) GetDatasetIds() []string {
	if m != nil {
		return m.DatasetIds
	}
	return nil
}

func (m *SearchVariantSetsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *SearchVariantSetsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

// The search variant sets response.
type SearchVariantSetsResponse struct {
	// The variant sets belonging to the requested dataset.
	VariantSets []*VariantSet `protobuf:"bytes,1,rep,name=variant_sets,json=variantSets" json:"variant_sets,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// Provide this value in a subsequent request to return the next page of
	// results. This field will be empty if there aren't any additional results.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken" json:"next_page_token,omitempty"`
}

func (m *SearchVariantSetsResponse) Reset()                    { *m = SearchVariantSetsResponse{} }
func (m *SearchVariantSetsResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchVariantSetsResponse) ProtoMessage()               {}
func (*SearchVariantSetsResponse) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{12} }

func (m *SearchVariantSetsResponse) GetVariantSets() []*VariantSet {
	if m != nil {
		return m.VariantSets
	}
	return nil
}

func (m *SearchVariantSetsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// The delete variant set request.
type DeleteVariantSetRequest struct {
	// The ID of the variant set to be deleted.
	VariantSetId string `protobuf:"bytes,1,opt,name=variant_set_id,json=variantSetId" json:"variant_set_id,omitempty"`
}

func (m *DeleteVariantSetRequest) Reset()                    { *m = DeleteVariantSetRequest{} }
func (m *DeleteVariantSetRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteVariantSetRequest) ProtoMessage()               {}
func (*DeleteVariantSetRequest) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{13} }

func (m *DeleteVariantSetRequest) GetVariantSetId() string {
	if m != nil {
		return m.VariantSetId
	}
	return ""
}

type UpdateVariantSetRequest struct {
	// The ID of the variant to be updated (must already exist).
	VariantSetId string `protobuf:"bytes,1,opt,name=variant_set_id,json=variantSetId" json:"variant_set_id,omitempty"`
	// The new variant data. Only the variant_set.metadata will be considered
	// for update.
	VariantSet *VariantSet `protobuf:"bytes,2,opt,name=variant_set,json=variantSet" json:"variant_set,omitempty"`
	// An optional mask specifying which fields to update. Supported fields:
	//
	// * [metadata][google.genomics.v1.VariantSet.metadata].
	// * [name][google.genomics.v1.VariantSet.name].
	// * [description][google.genomics.v1.VariantSet.description].
	//
	// Leaving `updateMask` unset is equivalent to specifying all mutable
	// fields.
	UpdateMask *google_protobuf2.FieldMask `protobuf:"bytes,5,opt,name=update_mask,json=updateMask" json:"update_mask,omitempty"`
}

func (m *UpdateVariantSetRequest) Reset()                    { *m = UpdateVariantSetRequest{} }
func (m *UpdateVariantSetRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateVariantSetRequest) ProtoMessage()               {}
func (*UpdateVariantSetRequest) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{14} }

func (m *UpdateVariantSetRequest) GetVariantSetId() string {
	if m != nil {
		return m.VariantSetId
	}
	return ""
}

func (m *UpdateVariantSetRequest) GetVariantSet() *VariantSet {
	if m != nil {
		return m.VariantSet
	}
	return nil
}

func (m *UpdateVariantSetRequest) GetUpdateMask() *google_protobuf2.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

// The variant search request.
type SearchVariantsRequest struct {
	// At most one variant set ID must be provided. Only variants from this
	// variant set will be returned. If omitted, a call set id must be included in
	// the request.
	VariantSetIds []string `protobuf:"bytes,1,rep,name=variant_set_ids,json=variantSetIds" json:"variant_set_ids,omitempty"`
	// Only return variants which have exactly this name.
	VariantName string `protobuf:"bytes,2,opt,name=variant_name,json=variantName" json:"variant_name,omitempty"`
	// Only return variant calls which belong to call sets with these ids.
	// Leaving this blank returns all variant calls. If a variant has no
	// calls belonging to any of these call sets, it won't be returned at all.
	CallSetIds []string `protobuf:"bytes,3,rep,name=call_set_ids,json=callSetIds" json:"call_set_ids,omitempty"`
	// Required. Only return variants in this reference sequence.
	ReferenceName string `protobuf:"bytes,4,opt,name=reference_name,json=referenceName" json:"reference_name,omitempty"`
	// The beginning of the window (0-based, inclusive) for which
	// overlapping variants should be returned. If unspecified, defaults to 0.
	Start int64 `protobuf:"varint,5,opt,name=start" json:"start,omitempty"`
	// The end of the window, 0-based exclusive. If unspecified or 0, defaults to
	// the length of the reference.
	End int64 `protobuf:"varint,6,opt,name=end" json:"end,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// To get the next page of results, set this parameter to the value of
	// `nextPageToken` from the previous response.
	PageToken string `protobuf:"bytes,7,opt,name=page_token,json=pageToken" json:"page_token,omitempty"`
	// The maximum number of variants to return in a single page. If unspecified,
	// defaults to 5000. The maximum value is 10000.
	PageSize int32 `protobuf:"varint,8,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
	// The maximum number of calls to return in a single page. Note that this
	// limit may be exceeded in the event that a matching variant contains more
	// calls than the requested maximum. If unspecified, defaults to 5000. The
	// maximum value is 10000.
	MaxCalls int32 `protobuf:"varint,9,opt,name=max_calls,json=maxCalls" json:"max_calls,omitempty"`
}

func (m *SearchVariantsRequest) Reset()                    { *m = SearchVariantsRequest{} }
func (m *SearchVariantsRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchVariantsRequest) ProtoMessage()               {}
func (*SearchVariantsRequest) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{15} }

func (m *SearchVariantsRequest) GetVariantSetIds() []string {
	if m != nil {
		return m.VariantSetIds
	}
	return nil
}

func (m *SearchVariantsRequest) GetVariantName() string {
	if m != nil {
		return m.VariantName
	}
	return ""
}

func (m *SearchVariantsRequest) GetCallSetIds() []string {
	if m != nil {
		return m.CallSetIds
	}
	return nil
}

func (m *SearchVariantsRequest) GetReferenceName() string {
	if m != nil {
		return m.ReferenceName
	}
	return ""
}

func (m *SearchVariantsRequest) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SearchVariantsRequest) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *SearchVariantsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *SearchVariantsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *SearchVariantsRequest) GetMaxCalls() int32 {
	if m != nil {
		return m.MaxCalls
	}
	return 0
}

// The variant search response.
type SearchVariantsResponse struct {
	// The list of matching Variants.
	Variants []*Variant `protobuf:"bytes,1,rep,name=variants" json:"variants,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// Provide this value in a subsequent request to return the next page of
	// results. This field will be empty if there aren't any additional results.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken" json:"next_page_token,omitempty"`
}

func (m *SearchVariantsResponse) Reset()                    { *m = SearchVariantsResponse{} }
func (m *SearchVariantsResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchVariantsResponse) ProtoMessage()               {}
func (*SearchVariantsResponse) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{16} }

func (m *SearchVariantsResponse) GetVariants() []*Variant {
	if m != nil {
		return m.Variants
	}
	return nil
}

func (m *SearchVariantsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

type CreateVariantRequest struct {
	// The variant to be created.
	Variant *Variant `protobuf:"bytes,1,opt,name=variant" json:"variant,omitempty"`
}

func (m *CreateVariantRequest) Reset()                    { *m = CreateVariantRequest{} }
func (m *CreateVariantRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateVariantRequest) ProtoMessage()               {}
func (*CreateVariantRequest) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{17} }

func (m *CreateVariantRequest) GetVariant() *Variant {
	if m != nil {
		return m.Variant
	}
	return nil
}

type UpdateVariantRequest struct {
	// The ID of the variant to be updated.
	VariantId string `protobuf:"bytes,1,opt,name=variant_id,json=variantId" json:"variant_id,omitempty"`
	// The new variant data.
	Variant *Variant `protobuf:"bytes,2,opt,name=variant" json:"variant,omitempty"`
	// An optional mask specifying which fields to update. At this time, mutable
	// fields are [names][google.genomics.v1.Variant.names] and
	// [info][google.genomics.v1.Variant.info]. Acceptable values are "names" and
	// "info". If unspecified, all mutable fields will be updated.
	UpdateMask *google_protobuf2.FieldMask `protobuf:"bytes,3,opt,name=update_mask,json=updateMask" json:"update_mask,omitempty"`
}

func (m *UpdateVariantRequest) Reset()                    { *m = UpdateVariantRequest{} }
func (m *UpdateVariantRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateVariantRequest) ProtoMessage()               {}
func (*UpdateVariantRequest) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{18} }

func (m *UpdateVariantRequest) GetVariantId() string {
	if m != nil {
		return m.VariantId
	}
	return ""
}

func (m *UpdateVariantRequest) GetVariant() *Variant {
	if m != nil {
		return m.Variant
	}
	return nil
}

func (m *UpdateVariantRequest) GetUpdateMask() *google_protobuf2.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

type DeleteVariantRequest struct {
	// The ID of the variant to be deleted.
	VariantId string `protobuf:"bytes,1,opt,name=variant_id,json=variantId" json:"variant_id,omitempty"`
}

func (m *DeleteVariantRequest) Reset()                    { *m = DeleteVariantRequest{} }
func (m *DeleteVariantRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteVariantRequest) ProtoMessage()               {}
func (*DeleteVariantRequest) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{19} }

func (m *DeleteVariantRequest) GetVariantId() string {
	if m != nil {
		return m.VariantId
	}
	return ""
}

type GetVariantRequest struct {
	// The ID of the variant.
	VariantId string `protobuf:"bytes,1,opt,name=variant_id,json=variantId" json:"variant_id,omitempty"`
}

func (m *GetVariantRequest) Reset()                    { *m = GetVariantRequest{} }
func (m *GetVariantRequest) String() string            { return proto.CompactTextString(m) }
func (*GetVariantRequest) ProtoMessage()               {}
func (*GetVariantRequest) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{20} }

func (m *GetVariantRequest) GetVariantId() string {
	if m != nil {
		return m.VariantId
	}
	return ""
}

type MergeVariantsRequest struct {
	// The destination variant set.
	VariantSetId string `protobuf:"bytes,1,opt,name=variant_set_id,json=variantSetId" json:"variant_set_id,omitempty"`
	// The variants to be merged with existing variants.
	Variants []*Variant `protobuf:"bytes,2,rep,name=variants" json:"variants,omitempty"`
	// A mapping between info field keys and the InfoMergeOperations to
	// be performed on them.
	InfoMergeConfig map[string]InfoMergeOperation `protobuf:"bytes,3,rep,name=info_merge_config,json=infoMergeConfig" json:"info_merge_config,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value,enum=google.genomics.v1.InfoMergeOperation"`
}

func (m *MergeVariantsRequest) Reset()                    { *m = MergeVariantsRequest{} }
func (m *MergeVariantsRequest) String() string            { return proto.CompactTextString(m) }
func (*MergeVariantsRequest) ProtoMessage()               {}
func (*MergeVariantsRequest) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{21} }

func (m *MergeVariantsRequest) GetVariantSetId() string {
	if m != nil {
		return m.VariantSetId
	}
	return ""
}

func (m *MergeVariantsRequest) GetVariants() []*Variant {
	if m != nil {
		return m.Variants
	}
	return nil
}

func (m *MergeVariantsRequest) GetInfoMergeConfig() map[string]InfoMergeOperation {
	if m != nil {
		return m.InfoMergeConfig
	}
	return nil
}

// The call set search request.
type SearchCallSetsRequest struct {
	// Restrict the query to call sets within the given variant sets. At least one
	// ID must be provided.
	VariantSetIds []string `protobuf:"bytes,1,rep,name=variant_set_ids,json=variantSetIds" json:"variant_set_ids,omitempty"`
	// Only return call sets for which a substring of the name matches this
	// string.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// To get the next page of results, set this parameter to the value of
	// `nextPageToken` from the previous response.
	PageToken string `protobuf:"bytes,3,opt,name=page_token,json=pageToken" json:"page_token,omitempty"`
	// The maximum number of results to return in a single page. If unspecified,
	// defaults to 1024.
	PageSize int32 `protobuf:"varint,4,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
}

func (m *SearchCallSetsRequest) Reset()                    { *m = SearchCallSetsRequest{} }
func (m *SearchCallSetsRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchCallSetsRequest) ProtoMessage()               {}
func (*SearchCallSetsRequest) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{22} }

func (m *SearchCallSetsRequest) GetVariantSetIds() []string {
	if m != nil {
		return m.VariantSetIds
	}
	return nil
}

func (m *SearchCallSetsRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SearchCallSetsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *SearchCallSetsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

// The call set search response.
type SearchCallSetsResponse struct {
	// The list of matching call sets.
	CallSets []*CallSet `protobuf:"bytes,1,rep,name=call_sets,json=callSets" json:"call_sets,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// Provide this value in a subsequent request to return the next page of
	// results. This field will be empty if there aren't any additional results.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken" json:"next_page_token,omitempty"`
}

func (m *SearchCallSetsResponse) Reset()                    { *m = SearchCallSetsResponse{} }
func (m *SearchCallSetsResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchCallSetsResponse) ProtoMessage()               {}
func (*SearchCallSetsResponse) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{23} }

func (m *SearchCallSetsResponse) GetCallSets() []*CallSet {
	if m != nil {
		return m.CallSets
	}
	return nil
}

func (m *SearchCallSetsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

type CreateCallSetRequest struct {
	// The call set to be created.
	CallSet *CallSet `protobuf:"bytes,1,opt,name=call_set,json=callSet" json:"call_set,omitempty"`
}

func (m *CreateCallSetRequest) Reset()                    { *m = CreateCallSetRequest{} }
func (m *CreateCallSetRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateCallSetRequest) ProtoMessage()               {}
func (*CreateCallSetRequest) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{24} }

func (m *CreateCallSetRequest) GetCallSet() *CallSet {
	if m != nil {
		return m.CallSet
	}
	return nil
}

type UpdateCallSetRequest struct {
	// The ID of the call set to be updated.
	CallSetId string `protobuf:"bytes,1,opt,name=call_set_id,json=callSetId" json:"call_set_id,omitempty"`
	// The new call set data.
	CallSet *CallSet `protobuf:"bytes,2,opt,name=call_set,json=callSet" json:"call_set,omitempty"`
	// An optional mask specifying which fields to update. At this time, the only
	// mutable field is [name][google.genomics.v1.CallSet.name]. The only
	// acceptable value is "name". If unspecified, all mutable fields will be
	// updated.
	UpdateMask *google_protobuf2.FieldMask `protobuf:"bytes,3,opt,name=update_mask,json=updateMask" json:"update_mask,omitempty"`
}

func (m *UpdateCallSetRequest) Reset()                    { *m = UpdateCallSetRequest{} }
func (m *UpdateCallSetRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateCallSetRequest) ProtoMessage()               {}
func (*UpdateCallSetRequest) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{25} }

func (m *UpdateCallSetRequest) GetCallSetId() string {
	if m != nil {
		return m.CallSetId
	}
	return ""
}

func (m *UpdateCallSetRequest) GetCallSet() *CallSet {
	if m != nil {
		return m.CallSet
	}
	return nil
}

func (m *UpdateCallSetRequest) GetUpdateMask() *google_protobuf2.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

type DeleteCallSetRequest struct {
	// The ID of the call set to be deleted.
	CallSetId string `protobuf:"bytes,1,opt,name=call_set_id,json=callSetId" json:"call_set_id,omitempty"`
}

func (m *DeleteCallSetRequest) Reset()                    { *m = DeleteCallSetRequest{} }
func (m *DeleteCallSetRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteCallSetRequest) ProtoMessage()               {}
func (*DeleteCallSetRequest) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{26} }

func (m *DeleteCallSetRequest) GetCallSetId() string {
	if m != nil {
		return m.CallSetId
	}
	return ""
}

type GetCallSetRequest struct {
	// The ID of the call set.
	CallSetId string `protobuf:"bytes,1,opt,name=call_set_id,json=callSetId" json:"call_set_id,omitempty"`
}

func (m *GetCallSetRequest) Reset()                    { *m = GetCallSetRequest{} }
func (m *GetCallSetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetCallSetRequest) ProtoMessage()               {}
func (*GetCallSetRequest) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{27} }

func (m *GetCallSetRequest) GetCallSetId() string {
	if m != nil {
		return m.CallSetId
	}
	return ""
}

// The stream variants request.
type StreamVariantsRequest struct {
	// The Google Cloud project ID which will be billed
	// for this access. The caller must have WRITE access to this project.
	// Required.
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId" json:"project_id,omitempty"`
	// The variant set ID from which to stream variants.
	VariantSetId string `protobuf:"bytes,2,opt,name=variant_set_id,json=variantSetId" json:"variant_set_id,omitempty"`
	// Only return variant calls which belong to call sets with these IDs.
	// Leaving this blank returns all variant calls.
	CallSetIds []string `protobuf:"bytes,3,rep,name=call_set_ids,json=callSetIds" json:"call_set_ids,omitempty"`
	// Required. Only return variants in this reference sequence.
	ReferenceName string `protobuf:"bytes,4,opt,name=reference_name,json=referenceName" json:"reference_name,omitempty"`
	// The beginning of the window (0-based, inclusive) for which
	// overlapping variants should be returned.
	Start int64 `protobuf:"varint,5,opt,name=start" json:"start,omitempty"`
	// The end of the window (0-based, exclusive) for which overlapping
	// variants should be returned.
	End int64 `protobuf:"varint,6,opt,name=end" json:"end,omitempty"`
}

func (m *StreamVariantsRequest) Reset()                    { *m = StreamVariantsRequest{} }
func (m *StreamVariantsRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamVariantsRequest) ProtoMessage()               {}
func (*StreamVariantsRequest) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{28} }

func (m *StreamVariantsRequest) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *StreamVariantsRequest) GetVariantSetId() string {
	if m != nil {
		return m.VariantSetId
	}
	return ""
}

func (m *StreamVariantsRequest) GetCallSetIds() []string {
	if m != nil {
		return m.CallSetIds
	}
	return nil
}

func (m *StreamVariantsRequest) GetReferenceName() string {
	if m != nil {
		return m.ReferenceName
	}
	return ""
}

func (m *StreamVariantsRequest) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *StreamVariantsRequest) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

type StreamVariantsResponse struct {
	Variants []*Variant `protobuf:"bytes,1,rep,name=variants" json:"variants,omitempty"`
}

func (m *StreamVariantsResponse) Reset()                    { *m = StreamVariantsResponse{} }
func (m *StreamVariantsResponse) String() string            { return proto.CompactTextString(m) }
func (*StreamVariantsResponse) ProtoMessage()               {}
func (*StreamVariantsResponse) Descriptor() ([]byte, []int) { return fileDescriptor11, []int{29} }

func (m *StreamVariantsResponse) GetVariants() []*Variant {
	if m != nil {
		return m.Variants
	}
	return nil
}

func init() {
	proto.RegisterType((*VariantSetMetadata)(nil), "google.genomics.v1.VariantSetMetadata")
	proto.RegisterType((*VariantSet)(nil), "google.genomics.v1.VariantSet")
	proto.RegisterType((*Variant)(nil), "google.genomics.v1.Variant")
	proto.RegisterType((*VariantCall)(nil), "google.genomics.v1.VariantCall")
	proto.RegisterType((*CallSet)(nil), "google.genomics.v1.CallSet")
	proto.RegisterType((*ReferenceBound)(nil), "google.genomics.v1.ReferenceBound")
	proto.RegisterType((*ImportVariantsRequest)(nil), "google.genomics.v1.ImportVariantsRequest")
	proto.RegisterType((*ImportVariantsResponse)(nil), "google.genomics.v1.ImportVariantsResponse")
	proto.RegisterType((*CreateVariantSetRequest)(nil), "google.genomics.v1.CreateVariantSetRequest")
	proto.RegisterType((*ExportVariantSetRequest)(nil), "google.genomics.v1.ExportVariantSetRequest")
	proto.RegisterType((*GetVariantSetRequest)(nil), "google.genomics.v1.GetVariantSetRequest")
	proto.RegisterType((*SearchVariantSetsRequest)(nil), "google.genomics.v1.SearchVariantSetsRequest")
	proto.RegisterType((*SearchVariantSetsResponse)(nil), "google.genomics.v1.SearchVariantSetsResponse")
	proto.RegisterType((*DeleteVariantSetRequest)(nil), "google.genomics.v1.DeleteVariantSetRequest")
	proto.RegisterType((*UpdateVariantSetRequest)(nil), "google.genomics.v1.UpdateVariantSetRequest")
	proto.RegisterType((*SearchVariantsRequest)(nil), "google.genomics.v1.SearchVariantsRequest")
	proto.RegisterType((*SearchVariantsResponse)(nil), "google.genomics.v1.SearchVariantsResponse")
	proto.RegisterType((*CreateVariantRequest)(nil), "google.genomics.v1.CreateVariantRequest")
	proto.RegisterType((*UpdateVariantRequest)(nil), "google.genomics.v1.UpdateVariantRequest")
	proto.RegisterType((*DeleteVariantRequest)(nil), "google.genomics.v1.DeleteVariantRequest")
	proto.RegisterType((*GetVariantRequest)(nil), "google.genomics.v1.GetVariantRequest")
	proto.RegisterType((*MergeVariantsRequest)(nil), "google.genomics.v1.MergeVariantsRequest")
	proto.RegisterType((*SearchCallSetsRequest)(nil), "google.genomics.v1.SearchCallSetsRequest")
	proto.RegisterType((*SearchCallSetsResponse)(nil), "google.genomics.v1.SearchCallSetsResponse")
	proto.RegisterType((*CreateCallSetRequest)(nil), "google.genomics.v1.CreateCallSetRequest")
	proto.RegisterType((*UpdateCallSetRequest)(nil), "google.genomics.v1.UpdateCallSetRequest")
	proto.RegisterType((*DeleteCallSetRequest)(nil), "google.genomics.v1.DeleteCallSetRequest")
	proto.RegisterType((*GetCallSetRequest)(nil), "google.genomics.v1.GetCallSetRequest")
	proto.RegisterType((*StreamVariantsRequest)(nil), "google.genomics.v1.StreamVariantsRequest")
	proto.RegisterType((*StreamVariantsResponse)(nil), "google.genomics.v1.StreamVariantsResponse")
	proto.RegisterEnum("google.genomics.v1.InfoMergeOperation", InfoMergeOperation_name, InfoMergeOperation_value)
	proto.RegisterEnum("google.genomics.v1.VariantSetMetadata_Type", VariantSetMetadata_Type_name, VariantSetMetadata_Type_value)
	proto.RegisterEnum("google.genomics.v1.ImportVariantsRequest_Format", ImportVariantsRequest_Format_name, ImportVariantsRequest_Format_value)
	proto.RegisterEnum("google.genomics.v1.ExportVariantSetRequest_Format", ExportVariantSetRequest_Format_name, ExportVariantSetRequest_Format_value)
}

func init() { proto.RegisterFile("google/genomics/v1/variants.proto", fileDescriptor11) }

var fileDescriptor11 = []byte{
	// 2317 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0x5f, 0x6f, 0xdb, 0xc8,
	0x11, 0x2f, 0x29, 0xc9, 0x96, 0x46, 0x96, 0xcc, 0x6c, 0x7c, 0x36, 0xa3, 0xfc, 0x73, 0xd8, 0x24,
	0xe7, 0x73, 0x53, 0x3b, 0xd1, 0x21, 0xd7, 0xab, 0x7b, 0xd7, 0xc0, 0x56, 0x64, 0x9f, 0x0a, 0x5b,
	0xf2, 0xd1, 0x4a, 0xda, 0x14, 0x28, 0x04, 0x5a, 0x5a, 0x3b, 0x4c, 0x24, 0x52, 0x21, 0x29, 0x37,
	0x76, 0x90, 0x87, 0x5e, 0xff, 0xe1, 0x80, 0x02, 0x05, 0x7a, 0x40, 0x9f, 0xfa, 0xda, 0x87, 0xa2,
	0x45, 0xbf, 0x41, 0xbe, 0x41, 0xdb, 0x97, 0xa2, 0xdf, 0xa0, 0x1f, 0xa2, 0x8f, 0xc5, 0x2e, 0x77,
	0x29, 0x92, 0x5a, 0x51, 0x72, 0x0e, 0x77, 0xb8, 0x37, 0xed, 0xec, 0xec, 0xce, 0xbf, 0xdf, 0xcc,
	0xce, 0x50, 0x70, 0xe3, 0xd8, 0xb6, 0x8f, 0xbb, 0x78, 0xfd, 0x18, 0x5b, 0x76, 0xcf, 0x6c, 0xbb,
	0xeb, 0x27, 0xf7, 0xd6, 0x4f, 0x0c, 0xc7, 0x34, 0x2c, 0xcf, 0x5d, 0xeb, 0x3b, 0xb6, 0x67, 0x23,
	0xe4, 0xb3, 0xac, 0x71, 0x96, 0xb5, 0x93, 0x7b, 0xa5, 0x2b, 0xec, 0x98, 0xd1, 0x37, 0xd7, 0x0d,
	0xcb, 0xb2, 0x3d, 0xc3, 0x33, 0x6d, 0x8b, 0x9d, 0x28, 0x7d, 0x9b, 0xed, 0x76, 0x6d, 0xeb, 0xd8,
	0x19, 0x58, 0x96, 0x69, 0x1d, 0xaf, 0xdb, 0x7d, 0xec, 0x44, 0x98, 0x2e, 0x33, 0x26, 0xba, 0x3a,
	0x1c, 0x1c, 0xad, 0xe3, 0x5e, 0xdf, 0x3b, 0x65, 0x9b, 0xcb, 0xf1, 0xcd, 0x23, 0x13, 0x77, 0x3b,
	0xad, 0x9e, 0xe1, 0x3e, 0x67, 0x1c, 0x57, 0xe2, 0x1c, 0xae, 0xe7, 0x0c, 0xda, 0x9e, 0xbf, 0xab,
	0xbd, 0x49, 0x01, 0x7a, 0xec, 0x9b, 0x71, 0x80, 0xbd, 0x3d, 0xec, 0x19, 0x1d, 0xc3, 0x33, 0x90,
	0x02, 0xa9, 0xe7, 0xf8, 0x54, 0x95, 0x96, 0xa5, 0x95, 0x9c, 0x4e, 0x7e, 0xa2, 0x05, 0xc8, 0x9c,
	0x18, 0xdd, 0x01, 0x56, 0x65, 0x4a, 0xf3, 0x17, 0xa8, 0x08, 0xb2, 0xd9, 0x51, 0xd3, 0x94, 0x24,
	0x9b, 0x1d, 0xf4, 0x00, 0xd2, 0xde, 0x69, 0x1f, 0xab, 0x99, 0x65, 0x69, 0xa5, 0x58, 0xfe, 0xce,
	0xda, 0xa8, 0x47, 0xd6, 0x46, 0xa5, 0xad, 0x35, 0x4f, 0xfb, 0x58, 0xa7, 0x07, 0xd1, 0x22, 0xcc,
	0x58, 0x83, 0xde, 0x21, 0x76, 0xd4, 0x2c, 0xbd, 0x94, 0xad, 0xd0, 0x32, 0xe4, 0x3b, 0xd8, 0x6d,
	0x3b, 0x66, 0x9f, 0xb8, 0x46, 0x9d, 0xa5, 0x9b, 0x61, 0x12, 0x7a, 0x08, 0x69, 0xd3, 0x3a, 0xb2,
	0xd5, 0xd4, 0x72, 0x6a, 0x25, 0x5f, 0xbe, 0x3b, 0xa5, 0xe8, 0x9a, 0x75, 0x64, 0x57, 0x2d, 0xcf,
	0x39, 0xd5, 0xe9, 0xe9, 0xd2, 0x01, 0xe4, 0x02, 0x92, 0xc0, 0x0b, 0x77, 0xc3, 0x5e, 0xc8, 0x97,
	0x4b, 0x5c, 0x0a, 0x77, 0xee, 0xda, 0xae, 0xe9, 0x7a, 0x8f, 0x09, 0x07, 0xf3, 0xd0, 0x86, 0xfc,
	0xa1, 0xa4, 0x3d, 0x81, 0x34, 0x31, 0x11, 0x2d, 0x80, 0xd2, 0x7c, 0xb2, 0x5f, 0x6d, 0x3d, 0xaa,
	0x1f, 0xec, 0x57, 0x2b, 0xb5, 0xed, 0x5a, 0xf5, 0xa1, 0xf2, 0x2d, 0x94, 0x87, 0xd9, 0x5a, 0xbd,
	0x59, 0xdd, 0xa9, 0xea, 0x8a, 0x84, 0x72, 0x90, 0xd9, 0xde, 0x6d, 0x6c, 0x36, 0x15, 0x19, 0x65,
	0x21, 0xbd, 0xbd, 0xbb, 0xb9, 0xa3, 0xa4, 0x50, 0x01, 0x72, 0x95, 0x4f, 0x36, 0xf5, 0xcd, 0x4a,
	0xb3, 0xaa, 0x2b, 0x69, 0x04, 0x30, 0x73, 0xd0, 0xd4, 0x6b, 0xf5, 0x1d, 0x25, 0xa3, 0xfd, 0x5d,
	0x06, 0x18, 0x9a, 0x85, 0xae, 0x02, 0x10, 0xb3, 0x5c, 0xec, 0xb5, 0xcc, 0x0e, 0x53, 0x3c, 0xc7,
	0x28, 0xb5, 0x0e, 0x0b, 0x97, 0x1c, 0x84, 0x6b, 0x05, 0x14, 0x07, 0x1f, 0x61, 0x07, 0x5b, 0x6d,
	0xdc, 0x62, 0x87, 0x66, 0xe8, 0x6e, 0x31, 0xa0, 0x1f, 0xd0, 0x93, 0x7b, 0x61, 0xce, 0x43, 0x7b,
	0x60, 0x75, 0x5c, 0x35, 0x43, 0x3d, 0xad, 0x89, 0x3c, 0xad, 0x73, 0xde, 0x2d, 0xc2, 0xaa, 0xcf,
	0x3b, 0x91, 0xb5, 0x8b, 0xb6, 0x20, 0xdb, 0x63, 0x21, 0x50, 0xd3, 0xf4, 0x9a, 0xdb, 0xd3, 0x05,
	0x4c, 0x0f, 0xce, 0x21, 0x04, 0x69, 0xcb, 0xe8, 0x61, 0x86, 0x05, 0xfa, 0x3b, 0x0e, 0x93, 0xec,
	0x08, 0x4c, 0xb4, 0xcf, 0xd3, 0x30, 0xcb, 0xae, 0x45, 0x37, 0xa1, 0xc8, 0x52, 0x98, 0x1b, 0x3f,
	0x4f, 0x0f, 0xcc, 0x9d, 0x04, 0x72, 0x05, 0x4e, 0x5b, 0x80, 0x0c, 0x91, 0xe5, 0x52, 0xa4, 0xe5,
	0x74, 0x7f, 0x81, 0x54, 0x98, 0x6d, 0x3b, 0xd8, 0xf0, 0x70, 0x47, 0x9d, 0x5b, 0x96, 0x56, 0x52,
	0x3a, 0x5f, 0xa2, 0x5b, 0x30, 0x74, 0x66, 0x8b, 0x6a, 0x5c, 0xa4, 0x77, 0x15, 0x02, 0x6a, 0x9d,
	0xa8, 0xbe, 0x00, 0x19, 0xd7, 0x33, 0x1c, 0x4f, 0x55, 0xe8, 0x71, 0x7f, 0x41, 0x20, 0x88, 0xad,
	0x8e, 0x5a, 0xa0, 0x34, 0xf2, 0x13, 0xbd, 0x0b, 0xf3, 0xa1, 0x48, 0x18, 0x2e, 0x76, 0x47, 0x42,
	0xb6, 0x45, 0xa8, 0x84, 0xd1, 0xe8, 0x7a, 0xd8, 0xb1, 0x0c, 0x8f, 0x33, 0xce, 0x52, 0x8d, 0x8b,
	0x01, 0xd9, 0x67, 0x54, 0x61, 0xf6, 0xc5, 0xc0, 0xe8, 0x9a, 0xde, 0x29, 0x75, 0x98, 0xa4, 0xf3,
	0x25, 0xc9, 0xc6, 0x23, 0x93, 0x30, 0xab, 0x39, 0x7a, 0x92, 0xad, 0xd0, 0xf7, 0x59, 0xae, 0x01,
	0x0d, 0xdd, 0xad, 0x84, 0xd0, 0xc5, 0x13, 0x0c, 0xdd, 0x87, 0x4c, 0xdb, 0xe8, 0x76, 0x5d, 0x35,
	0x4f, 0xcf, 0x5e, 0x4f, 0x38, 0x5b, 0x31, 0xba, 0x5d, 0xdd, 0xe7, 0xfe, 0x6a, 0xf2, 0xf2, 0x5f,
	0x32, 0xe4, 0x43, 0xb2, 0xd0, 0x35, 0xc8, 0x13, 0x69, 0x1c, 0x0c, 0x3e, 0x7a, 0x72, 0x84, 0xe4,
	0x23, 0x41, 0x83, 0x42, 0xb0, 0x4f, 0x03, 0x99, 0xf3, 0xf1, 0xc5, 0x38, 0x68, 0x18, 0x4b, 0x90,
	0x25, 0xa6, 0xd0, 0x2a, 0x48, 0xdc, 0x9d, 0xd1, 0x83, 0x35, 0xd9, 0xeb, 0x3f, 0x25, 0x2e, 0xc7,
	0x1e, 0xad, 0x90, 0x39, 0x3d, 0x58, 0xa3, 0x75, 0xb8, 0xc8, 0xf9, 0x5a, 0x5d, 0xf3, 0x39, 0xee,
	0x9a, 0x4f, 0x6d, 0x9b, 0x64, 0x63, 0x6a, 0x45, 0xd2, 0x11, 0xdf, 0xda, 0x0d, 0x76, 0xd0, 0xc7,
	0x2c, 0x06, 0x32, 0xf5, 0xe3, 0x7b, 0x13, 0xfc, 0xf8, 0xf5, 0x14, 0xba, 0x3f, 0xc9, 0x30, 0x5b,
	0xf1, 0x9d, 0xc1, 0xd2, 0x46, 0x0a, 0xd2, 0x86, 0xa7, 0xab, 0x1c, 0x4a, 0xd7, 0xcb, 0x90, 0x73,
	0x8d, 0x5e, 0xbf, 0x8b, 0x89, 0xbb, 0xfd, 0x3c, 0xce, 0xfa, 0x84, 0x5a, 0x07, 0xdd, 0x86, 0xf9,
	0x68, 0x76, 0xba, 0xd4, 0x1b, 0x39, 0xbd, 0x10, 0x4e, 0xcf, 0x48, 0xe6, 0x65, 0xa2, 0x99, 0xc7,
	0x61, 0x9a, 0x1e, 0x0f, 0x53, 0xa6, 0xed, 0xd7, 0xe3, 0x9e, 0x9f, 0x40, 0x31, 0x5a, 0x18, 0x05,
	0xb5, 0x41, 0x12, 0xd5, 0x86, 0xeb, 0x90, 0x1f, 0xf4, 0xfb, 0xd8, 0xf1, 0x2b, 0x2f, 0x15, 0x9a,
	0xd2, 0x81, 0x92, 0xe8, 0x3d, 0xda, 0xef, 0xd2, 0xf0, 0x4e, 0xad, 0xd7, 0xb7, 0x1d, 0x8f, 0xc5,
	0xdc, 0xd5, 0xf1, 0x8b, 0x01, 0x76, 0x45, 0x35, 0x4e, 0x12, 0xd4, 0xb8, 0xeb, 0x90, 0x77, 0xed,
	0x81, 0xd3, 0xc6, 0xad, 0x81, 0x63, 0xba, 0x14, 0x53, 0x39, 0x1d, 0x7c, 0xd2, 0x23, 0xc7, 0x74,
	0xd1, 0x27, 0x30, 0x73, 0x64, 0x3b, 0x3d, 0xc3, 0x53, 0x53, 0xf4, 0x69, 0x17, 0xbe, 0xaf, 0x42,
	0x0d, 0xd6, 0xb6, 0xe9, 0x39, 0x9d, 0x9d, 0x47, 0x1b, 0x70, 0xc9, 0x22, 0xbf, 0xba, 0xe6, 0x19,
	0x6e, 0x45, 0x8d, 0x77, 0x69, 0x00, 0xb3, 0xfa, 0x52, 0xc0, 0xa0, 0x87, 0xdd, 0xe0, 0xa2, 0x67,
	0x70, 0x81, 0x44, 0xa7, 0xd5, 0xc3, 0xce, 0x31, 0x6e, 0xb5, 0x6d, 0xeb, 0xc8, 0x3c, 0xa6, 0xa0,
	0xc8, 0x97, 0x7f, 0x38, 0xbd, 0x42, 0x24, 0xb0, 0x7b, 0xe4, 0x86, 0x0a, 0xbd, 0xc0, 0x0f, 0xfb,
	0xbc, 0x19, 0xa5, 0x96, 0x9e, 0xc1, 0x82, 0x88, 0x51, 0x00, 0x86, 0x8f, 0xc2, 0x60, 0x28, 0x8a,
	0x5f, 0xb2, 0xe0, 0xaa, 0x06, 0x6f, 0xef, 0xc2, 0xc0, 0xa8, 0xc3, 0x8c, 0xef, 0x25, 0xb4, 0x08,
	0x68, 0xbb, 0xa1, 0xef, 0x6d, 0x36, 0x63, 0x4d, 0x42, 0x11, 0x80, 0xd1, 0x1f, 0x57, 0xb6, 0x15,
	0x09, 0x5d, 0x01, 0x95, 0xad, 0x2b, 0x8d, 0xbd, 0xfd, 0xdd, 0x6a, 0xb3, 0xda, 0xda, 0xa9, 0xd6,
	0x1b, 0x7b, 0xb5, 0xca, 0x81, 0x22, 0x6b, 0x1b, 0xb0, 0x18, 0x37, 0xdd, 0xed, 0xdb, 0x96, 0x4b,
	0x1e, 0xc8, 0xb9, 0x50, 0x89, 0x73, 0x55, 0xc9, 0x8f, 0x74, 0x50, 0xe3, 0x5c, 0xed, 0xa7, 0xb0,
	0x54, 0xa1, 0xf9, 0x33, 0x7c, 0x7c, 0x39, 0x96, 0x1e, 0x40, 0x3e, 0x84, 0x25, 0xea, 0x82, 0x7c,
	0xf9, 0x5a, 0xf2, 0xc3, 0xad, 0xc3, 0x10, 0x68, 0xda, 0x7f, 0x64, 0x58, 0xaa, 0xbe, 0x0c, 0x29,
	0x16, 0xba, 0x7c, 0x3a, 0xa0, 0xc6, 0xf5, 0x97, 0xe3, 0xfa, 0x93, 0x16, 0xa8, 0xef, 0xd8, 0xcf,
	0x70, 0x9b, 0xde, 0x91, 0xf2, 0x6b, 0x38, 0xa3, 0xd4, 0x3a, 0xe8, 0x47, 0x01, 0x90, 0xd3, 0x34,
	0x5a, 0x65, 0x91, 0xfa, 0x63, 0x74, 0x8c, 0x43, 0xf9, 0x3d, 0x50, 0x0e, 0xcd, 0xe3, 0x17, 0x03,
	0xec, 0x9c, 0xb6, 0x58, 0x93, 0xc5, 0xea, 0xfa, 0x3c, 0xa7, 0x3f, 0xf4, 0xc9, 0x24, 0xd1, 0x03,
	0x56, 0xcf, 0x38, 0xec, 0x62, 0xf6, 0x68, 0x17, 0x38, 0xb5, 0x49, 0x88, 0xda, 0xfd, 0x89, 0x40,
	0xb8, 0x08, 0xf3, 0x8c, 0xbe, 0x55, 0xdb, 0xf9, 0xf4, 0x51, 0x55, 0x7f, 0xa2, 0x48, 0xda, 0x47,
	0xb0, 0xb0, 0x83, 0xdf, 0xd6, 0xa7, 0xda, 0xcf, 0x41, 0x3d, 0xc0, 0x86, 0xd3, 0x7e, 0x3a, 0xbc,
	0x20, 0x28, 0x1f, 0xd7, 0x21, 0x3f, 0x6c, 0x28, 0x03, 0xb8, 0x04, 0x1d, 0xa5, 0xef, 0x6e, 0xe3,
	0x18, 0xb7, 0x3c, 0xfb, 0x39, 0xb6, 0x58, 0x71, 0xcf, 0x11, 0x4a, 0x93, 0x10, 0x48, 0x85, 0xa7,
	0xdb, 0xae, 0x79, 0x86, 0x69, 0x30, 0x32, 0x7a, 0x96, 0x10, 0x0e, 0xcc, 0x33, 0xac, 0xfd, 0x46,
	0x82, 0x4b, 0x02, 0xc9, 0x0c, 0xaa, 0x9b, 0x30, 0x17, 0x52, 0xde, 0x97, 0x3d, 0x19, 0x6e, 0xf9,
	0xa1, 0x69, 0x2e, 0x79, 0x42, 0x2c, 0xfc, 0xd2, 0x6b, 0x8d, 0x68, 0x58, 0x20, 0xe4, 0x7d, 0xae,
	0xa5, 0xf6, 0x00, 0x96, 0x1e, 0xe2, 0x2e, 0x16, 0x61, 0x7e, 0x3a, 0x17, 0xbe, 0x91, 0x60, 0xe9,
	0x51, 0xbf, 0x63, 0xbc, 0xf5, 0x0d, 0xf1, 0xdc, 0x92, 0xcf, 0x9b, 0x5b, 0xe8, 0x07, 0xe4, 0x8d,
	0x20, 0x1a, 0xd0, 0xe1, 0x8f, 0xe2, 0x50, 0xf4, 0x30, 0x6d, 0x93, 0xf9, 0x70, 0xcf, 0x70, 0x9f,
	0x93, 0xf7, 0x83, 0xb0, 0x93, 0xdf, 0xda, 0xdf, 0x64, 0x78, 0x27, 0x12, 0x89, 0x00, 0x00, 0x82,
	0x57, 0x58, 0x12, 0xbd, 0xc2, 0x37, 0x86, 0xd1, 0x0a, 0x3d, 0xf3, 0xdc, 0xa6, 0xba, 0xdf, 0x9c,
	0x47, 0x73, 0x37, 0x35, 0x92, 0xbb, 0xa3, 0xcf, 0x61, 0x3a, 0xb1, 0x55, 0xce, 0x08, 0x5a, 0xe5,
	0x99, 0x61, 0xab, 0x1c, 0xc5, 0xe6, 0x6c, 0x22, 0x36, 0xb3, 0x51, 0x6c, 0x92, 0xcd, 0x9e, 0xf1,
	0xb2, 0xe5, 0xf7, 0xaa, 0x39, 0x7f, 0xb3, 0x67, 0xbc, 0x24, 0xfd, 0x82, 0xab, 0x9d, 0xc2, 0x62,
	0xdc, 0x5b, 0x0c, 0xb4, 0xdf, 0x83, 0x2c, 0xff, 0x2a, 0xc0, 0x00, 0x7b, 0x39, 0x21, 0x86, 0x7a,
	0xc0, 0x3c, 0x35, 0x54, 0xf7, 0x60, 0x21, 0x52, 0x9e, 0x79, 0x9c, 0xee, 0xc3, 0x2c, 0xbb, 0x8b,
	0xd5, 0xe5, 0x44, 0xb9, 0x9c, 0x57, 0xfb, 0x8b, 0x04, 0x0b, 0x11, 0xe0, 0xf2, 0xfb, 0xae, 0x02,
	0x07, 0x57, 0x68, 0x92, 0x64, 0x94, 0x5a, 0x27, 0x2c, 0x4e, 0x9e, 0x5e, 0x5c, 0x1c, 0xa4, 0xa9,
	0x73, 0x81, 0xf4, 0x3e, 0x2c, 0x44, 0xb2, 0x74, 0x3a, 0x55, 0xb5, 0x32, 0x5c, 0x18, 0x16, 0xc7,
	0x29, 0xcf, 0xfc, 0x43, 0x86, 0x05, 0xfa, 0x5c, 0xbf, 0x5d, 0x3b, 0x15, 0x46, 0x81, 0x7c, 0x1e,
	0x14, 0x98, 0xa2, 0x06, 0xc7, 0xff, 0xa2, 0xf1, 0xb1, 0xe8, 0x06, 0x91, 0x8e, 0xdf, 0xc0, 0xfe,
	0xe6, 0xf7, 0x12, 0x2f, 0x2f, 0xac, 0xdf, 0x3e, 0x77, 0x79, 0x11, 0x4d, 0x0f, 0xd1, 0xf4, 0x4e,
	0x25, 0xa6, 0x77, 0x3a, 0xf6, 0xf4, 0x9c, 0xf1, 0x0c, 0x1e, 0x2a, 0xc4, 0x32, 0xf8, 0x43, 0xc8,
	0xf1, 0x2a, 0x95, 0x98, 0xc2, 0xec, 0xa0, 0x9e, 0x65, 0xf5, 0x6b, 0xfa, 0x14, 0xae, 0xf3, 0x14,
	0xe6, 0x57, 0x30, 0x5f, 0x7c, 0x00, 0x59, 0x2e, 0x39, 0x29, 0x87, 0xf9, 0xa9, 0x59, 0x26, 0x58,
	0xfb, 0x6b, 0x90, 0xc3, 0xb1, 0x0b, 0x63, 0xf3, 0xac, 0x14, 0x9f, 0x67, 0xc3, 0x02, 0xe5, 0xe9,
	0x05, 0x7e, 0xb9, 0x2c, 0xfe, 0x80, 0x67, 0xf1, 0xf9, 0x94, 0xd5, 0xde, 0xa7, 0x69, 0x7c, 0xce,
	0x43, 0xff, 0x24, 0xc0, 0xf3, 0x1c, 0x6c, 0xf4, 0xe2, 0x89, 0x1c, 0x6d, 0x13, 0xa5, 0x78, 0x9b,
	0x38, 0x9a, 0xe7, 0xf2, 0x14, 0xdd, 0xe8, 0x57, 0xfd, 0xa2, 0x69, 0x9f, 0xc2, 0x62, 0xdc, 0x9c,
	0x2f, 0xf9, 0xf0, 0xac, 0xfe, 0x0c, 0xd0, 0x68, 0xf2, 0xa2, 0x9b, 0xb0, 0x5c, 0xab, 0x6f, 0x37,
	0x5a, 0x7b, 0x55, 0x7d, 0xa7, 0xda, 0x6a, 0xec, 0x57, 0xf5, 0xcd, 0x66, 0xad, 0x51, 0x1f, 0x9d,
	0x4a, 0x6a, 0x3b, 0xf5, 0x86, 0x5e, 0x6d, 0xd5, 0xab, 0x3f, 0x56, 0x24, 0x74, 0x01, 0x0a, 0x7b,
	0x8d, 0xc7, 0xd5, 0x56, 0xb3, 0xd1, 0xaa, 0x6c, 0xee, 0xee, 0x1e, 0x28, 0x72, 0xf9, 0xcf, 0x12,
	0x2c, 0xf9, 0x2a, 0x9b, 0xd6, 0x71, 0xd0, 0xba, 0x38, 0x27, 0x66, 0x1b, 0xa3, 0xcf, 0x25, 0x28,
	0x46, 0xcd, 0x41, 0xc2, 0xef, 0x18, 0xc2, 0x08, 0x96, 0x56, 0xa7, 0x61, 0xf5, 0xbd, 0xa3, 0x5d,
	0xfb, 0xec, 0xdf, 0xff, 0xfd, 0x42, 0x56, 0xb5, 0x8b, 0xe1, 0xcf, 0xf6, 0x1b, 0x2e, 0x65, 0xde,
	0x90, 0x56, 0xef, 0x4a, 0xe5, 0x37, 0x08, 0x94, 0xa8, 0x7a, 0x8f, 0xef, 0xa1, 0x33, 0x28, 0x46,
	0xe7, 0x28, 0xb1, 0x7e, 0xc2, 0x31, 0xb3, 0x74, 0x95, 0xb3, 0x86, 0xbe, 0xee, 0xaf, 0x05, 0x1e,
	0x1e, 0xa3, 0x92, 0x49, 0xaf, 0xda, 0x90, 0x56, 0xd1, 0xaf, 0x25, 0x50, 0xe2, 0x83, 0x18, 0x12,
	0x7e, 0x51, 0x1f, 0x33, 0xae, 0x95, 0x26, 0x74, 0x8f, 0xda, 0x4d, 0xaa, 0xc1, 0x35, 0x6d, 0x3e,
	0xac, 0x01, 0xf6, 0xdc, 0x8d, 0x70, 0x27, 0x8a, 0xfe, 0x20, 0x81, 0x12, 0x9f, 0x87, 0xc4, 0x7a,
	0x8c, 0x99, 0x9a, 0x26, 0x39, 0xa2, 0x4c, 0xd5, 0xb8, 0xa3, 0xbd, 0x1b, 0x53, 0x63, 0xfd, 0x55,
	0x34, 0x03, 0x5f, 0x6f, 0xe0, 0x97, 0xdc, 0x39, 0xbf, 0x94, 0xa0, 0x10, 0x99, 0x78, 0xd0, 0x8a,
	0x48, 0x23, 0xd1, 0x50, 0x34, 0xd1, 0x2d, 0x2b, 0x54, 0x1f, 0x0d, 0x2d, 0x4f, 0xd2, 0x07, 0x7d,
	0x21, 0xc1, 0x85, 0x91, 0xf9, 0x05, 0xdd, 0x11, 0xe2, 0x72, 0xcc, 0x80, 0x55, 0xfa, 0xee, 0x94,
	0xdc, 0x0c, 0xc8, 0x37, 0xa8, 0x72, 0x97, 0xb5, 0xc5, 0xb8, 0x72, 0x2e, 0x3d, 0x42, 0x7c, 0xf3,
	0x0b, 0x09, 0x94, 0xf8, 0x34, 0x23, 0x0e, 0xd8, 0x98, 0x99, 0xa7, 0xb4, 0x38, 0x52, 0xca, 0xab,
	0xbd, 0xbe, 0x77, 0xca, 0x3d, 0xb3, 0x3a, 0xd9, 0x33, 0x7f, 0x94, 0x40, 0x89, 0xcf, 0x43, 0x62,
	0x1d, 0xc6, 0x4c, 0x4d, 0x13, 0xa3, 0x74, 0x9f, 0xea, 0xb2, 0x5e, 0x9e, 0xa8, 0x4b, 0x14, 0xcd,
	0xbf, 0x25, 0x25, 0x27, 0xd2, 0xba, 0x8f, 0x29, 0x39, 0xa2, 0x61, 0x68, 0x4c, 0xc9, 0x11, 0x4e,
	0x02, 0xe2, 0xfc, 0x0e, 0x85, 0x69, 0x00, 0x85, 0x48, 0xe2, 0x8a, 0x11, 0x2c, 0xea, 0xf5, 0x4b,
	0x49, 0x95, 0x5d, 0xbb, 0x4a, 0xe5, 0x2e, 0x69, 0x73, 0x91, 0xba, 0x12, 0x74, 0xe0, 0x9f, 0x49,
	0x50, 0x88, 0xf8, 0x5c, 0x2c, 0x57, 0x34, 0x13, 0x24, 0xcb, 0x5d, 0xa5, 0x72, 0x6f, 0x96, 0x2f,
	0x45, 0xec, 0x7d, 0x35, 0xec, 0xb2, 0x5f, 0x0f, 0x95, 0xf0, 0xa0, 0x10, 0xc1, 0x9e, 0x58, 0x07,
	0x51, 0xb3, 0x3f, 0x16, 0x9b, 0x2c, 0x31, 0x56, 0xc7, 0x8b, 0x47, 0x2e, 0xc0, 0xb0, 0x20, 0xa0,
	0x5b, 0xc9, 0x05, 0x63, 0x2a, 0x9b, 0x99, 0x50, 0x94, 0x20, 0xb4, 0x0f, 0x85, 0x48, 0x93, 0x2e,
	0x36, 0x55, 0xd4, 0xc7, 0x8f, 0x35, 0x95, 0x47, 0x18, 0x45, 0x22, 0x4c, 0x47, 0x06, 0x02, 0xac,
	0x21, 0xc4, 0x79, 0x6f, 0x9b, 0x04, 0xf1, 0x58, 0x43, 0x9e, 0x04, 0xf1, 0x78, 0xab, 0x1c, 0x85,
	0x38, 0x9d, 0x94, 0xa3, 0x95, 0xe8, 0x84, 0x43, 0x9c, 0xff, 0x27, 0x90, 0x00, 0xf1, 0x68, 0x63,
	0x57, 0x4a, 0x6a, 0x44, 0x03, 0xb9, 0x73, 0x61, 0xb9, 0x1b, 0x41, 0x2f, 0x8b, 0x7e, 0x15, 0x60,
	0x3c, 0x51, 0xb0, 0xa8, 0x67, 0x4e, 0x16, 0x7c, 0x87, 0x0a, 0xbe, 0x5d, 0x2e, 0x45, 0x0c, 0x7e,
	0x15, 0xea, 0x01, 0x5f, 0x87, 0xd4, 0x18, 0x70, 0x94, 0x27, 0x6a, 0x21, 0x6a, 0x86, 0xc7, 0x86,
	0x5e, 0xa3, 0x0a, 0x5c, 0x59, 0x4d, 0x50, 0x00, 0x79, 0x14, 0xe6, 0x5c, 0xe6, 0x38, 0x98, 0x9f,
	0xc7, 0x6c, 0x26, 0x15, 0x25, 0x48, 0xdd, 0xba, 0x03, 0x8b, 0x6d, 0xbb, 0x27, 0xb8, 0x65, 0xab,
	0xc0, 0x71, 0xbd, 0x4f, 0x6c, 0xd9, 0x97, 0xfe, 0x27, 0x49, 0x87, 0x33, 0xd4, 0xae, 0xf7, 0xff,
	0x1f, 0x00, 0x00, 0xff, 0xff, 0xf4, 0xfd, 0xe2, 0x64, 0x56, 0x21, 0x00, 0x00,
}
